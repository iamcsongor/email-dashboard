<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Comms Dashboard</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/@azure/msal-browser@3.0.0/lib/msal-browser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
  /* â”€â”€ Design Tokens â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  :root {
    /* Glass system */
    --glass-opacity: 0.16;
    --glass-blur: 30px;
    --glass-radius: 24px;
    --glass-border: rgba(255,255,255,0.25);
    --glass-shadow: 0 20px 60px rgba(0,0,0,0.25);
    --glass-highlight: inset 0 1px 0 rgba(255,255,255,0.35);
    --glass-gradient: linear-gradient(to bottom, rgba(255,255,255,0.20), rgba(255,255,255,0.10));

    /* Text */
    --text-primary: rgba(255,255,255,0.9);
    --text-secondary: rgba(255,255,255,0.65);

    /* Motion */
    --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
    --duration-hover: 250ms;
    --duration-state: 350ms;

    /* Dashboard tokens (unchanged) */
    --bg:       #f0f2f9;
    --card:     #ffffff;
    --primary:  #5b6af9;
    --sent:     #f97066;
    --received: #5b6af9;
    --green:    #22c55e;
    --text-d:   #1e2035;
    --muted:    #6b7280;
    --border:   #e5e7eb;
    --radius:   14px;
    --shadow:   0 2px 16px rgba(0,0,0,0.06);
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text-d);
    min-height: 100vh;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     LEVEL 0 â€” Background Image (Depth-Blur)
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  #login-screen {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    position: relative;
    overflow: hidden;
    background: #1a2e0a;
  }

  /* Photographic background â€” heavy Gaussian blur removes all fine detail */
  #login-screen::before {
    content: '';
    position: absolute;
    inset: -10%;
    z-index: 0;
    background:
      /* Warm sun-ray spill, upper-left (ambient light source) */
      radial-gradient(ellipse 60% 55% at 28% 12%, rgba(235,218,160,0.70) 0%, rgba(190,200,120,0.30) 40%, transparent 68%),
      /* Secondary warm glow, upper-right */
      radial-gradient(ellipse 45% 40% at 72% 8%, rgba(210,195,140,0.45) 0%, transparent 60%),
      /* Bright rolling hill crest â€” mid-frame */
      radial-gradient(ellipse 100% 30% at 50% 48%, rgba(140,185,75,0.65) 0%, rgba(100,148,50,0.35) 50%, transparent 78%),
      /* Soft meadow light, center-left */
      radial-gradient(ellipse 35% 38% at 32% 42%, rgba(155,195,90,0.40) 0%, transparent 65%),
      /* Mid-ground tree mass, right */
      radial-gradient(ellipse 42% 55% at 78% 65%, rgba(22,52,14,0.85) 0%, rgba(38,72,22,0.45) 50%, transparent 75%),
      /* Dark canopy, top-left frame */
      radial-gradient(ellipse 50% 45% at 10% 5%, rgba(10,24,5,0.88) 0%, transparent 55%),
      /* Deep shadow, bottom */
      radial-gradient(ellipse 100% 40% at 50% 95%, rgba(8,18,4,0.75) 0%, transparent 70%),
      /* Base landscape gradient */
      linear-gradient(168deg, #0c1e04 0%, #1a3008 15%, #2c5212 32%, #3e7218 50%, #4a7c1c 65%, #365a10 80%, #142408 100%);
    filter: blur(60px) saturate(85%);
  }

  /* Tonal treatment: warm upper half + dark vignette bottom */
  #login-screen::after {
    content: '';
    position: absolute;
    inset: 0;
    z-index: 0;
    background:
      /* Subtle warmth top half */
      linear-gradient(180deg, rgba(200,180,120,0.08) 0%, transparent 50%),
      /* Dark vignette bottom */
      linear-gradient(0deg, rgba(0,0,0,0.32) 0%, transparent 45%),
      /* Corner vignette */
      radial-gradient(ellipse 80% 80% at 50% 50%, transparent 40%, rgba(0,0,0,0.22) 100%);
    pointer-events: none;
  }

  /* Animated orbs removed */
  .glass-orb { display: none; }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     LEVEL 1 â€” Primary Glass Container
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .login-card {
    background: rgba(255, 255, 255, var(--glass-opacity));
    backdrop-filter: blur(var(--glass-blur)) saturate(120%);
    -webkit-backdrop-filter: blur(var(--glass-blur)) saturate(120%);
    border: 1px solid var(--glass-border);
    border-radius: var(--glass-radius);
    padding: 48px 40px 32px;
    box-shadow: var(--glass-shadow);
    text-align: center;
    width: 400px;
    position: relative;
    z-index: 1;
    overflow: hidden;
  }

  /* Internal lighting gradient â€” top-left ambient source */
  .login-card::before {
    content: '';
    position: absolute;
    inset: 0;
    background: var(--glass-gradient);
    border-radius: var(--glass-radius);
    pointer-events: none;
  }

  /* Top-edge highlight (specular from ambient light) */
  .login-card::after {
    content: '';
    position: absolute;
    top: 0; left: 8%; right: 8%;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.35) 30%, rgba(255,255,255,0.35) 70%, transparent);
    pointer-events: none;
  }

  .login-icon { font-size: 2rem; margin-bottom: 16px; }

  .login-card h1 {
    font-size: 1.4rem;
    color: var(--text-primary);
    margin-bottom: 8px;
    letter-spacing: -0.02em;
    font-weight: 600;
  }

  .login-card p {
    color: var(--text-secondary);
    font-size: 0.85rem;
    margin-bottom: 32px;
    line-height: 1.6;
    font-weight: 400;
  }

  #error-msg {
    display: none;
    background: rgba(180, 30, 20, 0.14);
    backdrop-filter: blur(12px);
    color: rgba(255,180,170,0.9);
    border: 1px solid rgba(255, 200, 190, 0.15);
    border-radius: 12px;
    padding: 12px 16px;
    font-size: 0.82rem;
    margin-bottom: 16px;
    text-align: left;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     LEVEL 2 â€” Radial Time Slider (Raised Surface)
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .time-slider-section {
    margin: 0 0 32px;
    padding: 0;
    background: none;
    border: none;
    border-radius: 0;
  }

  .time-slider-label {
    font-size: 0.7rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-secondary);
    margin-bottom: 16px;
  }

  .time-slider-wrap {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #time-slider {
    cursor: pointer;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
    overflow: visible;
  }

  /* â”€â”€ Level 3: Slider Handle â€” Glass Bubble â”€â”€â”€â”€ */
  #slider-handle {
    transition: filter var(--duration-hover) var(--ease-out),
                transform var(--duration-hover) var(--ease-out);
    filter: drop-shadow(0 2px 8px rgba(0,0,0,0.35));
    cursor: grab;
  }
  #slider-handle:hover {
    filter: drop-shadow(0 0 12px rgba(255,255,255,0.35))
            drop-shadow(0 2px 8px rgba(0,0,0,0.30));
    transform: scale(1.02);
  }
  #slider-handle.dragging {
    cursor: grabbing;
    filter: drop-shadow(0 0 16px rgba(255,255,255,0.45))
            drop-shadow(0 2px 10px rgba(0,0,0,0.30));
    transform: scale(0.98);
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     LEVEL 2 â€” Sign-In Button (Raised Interactive)
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .btn-primary {
    background: rgba(255,255,255,0.14);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    color: var(--text-primary);
    border: 1px solid var(--glass-border);
    padding: 14px 28px;
    border-radius: 16px;
    font-size: 0.92rem;
    font-weight: 500;
    cursor: pointer;
    width: 100%;
    box-shadow:
      0 8px 32px rgba(0,0,0,0.18),
      var(--glass-highlight);
    transition: background var(--duration-hover) var(--ease-out),
                box-shadow var(--duration-hover) var(--ease-out),
                transform var(--duration-hover) var(--ease-out);
    letter-spacing: -0.005em;
    position: relative;
    overflow: hidden;
  }
  /* Internal light gradient on button */
  .btn-primary::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(to bottom, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
    border-radius: 16px;
    pointer-events: none;
  }
  .btn-primary:hover {
    background: rgba(255,255,255,0.20);
    box-shadow:
      0 12px 40px rgba(0,0,0,0.22),
      var(--glass-highlight);
    transform: translateY(-1px);
  }
  .btn-primary:active {
    transform: scale(0.98);
    box-shadow:
      0 4px 16px rgba(0,0,0,0.18),
      var(--glass-highlight);
  }
  .btn-primary:disabled { opacity: .4; cursor: default; transform: none; }

  /* â”€â”€ Loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #loading-screen {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    gap: 18px;
  }

  .spinner {
    width: 48px; height: 48px;
    border: 4px solid var(--border);
    border-top-color: var(--primary);
    border-radius: 50%;
    animation: spin .75s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  #loading-text     { font-weight: 600; }
  #loading-progress { font-size: .82rem; color: var(--muted); }

  .progress-bar-wrap {
    width: 260px; height: 4px;
    background: var(--border);
    border-radius: 99px;
    overflow: hidden;
  }
  .progress-bar-inner {
    height: 100%;
    background: var(--primary);
    border-radius: 99px;
    width: 0%;
    transition: width .3s;
  }

  /* â”€â”€ Dashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #dashboard { display: none; }

  header {
    background: var(--card);
    border-bottom: 1px solid var(--border);
    padding: 0 32px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: sticky; top: 0; z-index: 20;
  }

  .header-left { display: flex; align-items: center; gap: 10px; }
  .header-left h1 { font-size: 1rem; font-weight: 700; }
  #account-badge {
    font-size: .78rem;
    background: var(--bg);
    color: var(--muted);
    padding: 3px 10px;
    border-radius: 99px;
    border: 1px solid var(--border);
  }

  .btn-ghost {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--muted);
    padding: 6px 14px;
    border-radius: 8px;
    font-size: .82rem;
    cursor: pointer;
  }
  .btn-ghost:hover { background: var(--bg); }

  main {
    max-width: 1360px;
    margin: 0 auto;
    padding: 28px 32px 48px;
    display: flex;
    flex-direction: column;
    gap: 28px;
  }

  /* â”€â”€ Section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .section-label {
    font-size: .7rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .08em;
    color: var(--muted);
    margin-bottom: 14px;
  }

  /* â”€â”€ Stat cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(168px, 1fr));
    gap: 14px;
  }

  .stat-card {
    background: var(--card);
    border-radius: var(--radius);
    padding: 20px 22px;
    box-shadow: var(--shadow);
    display: flex;
    flex-direction: column;
    gap: 4px;
    cursor: pointer;
    transition: box-shadow .15s, transform .15s;
  }
  .stat-card:hover {
    box-shadow: 0 4px 24px rgba(0,0,0,0.12);
    transform: translateY(-1px);
  }

  .stat-label { font-size: .78rem; color: var(--muted); }
  .stat-value { font-size: 2rem; font-weight: 800; line-height: 1.1; }
  .stat-sub   { font-size: .73rem; color: var(--muted); margin-top: 2px; }

  .stat-card.c-received .stat-value { color: var(--received); }
  .stat-card.c-sent     .stat-value { color: var(--sent); }

  /* â”€â”€ Chart cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .charts-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 18px;
  }

  .chart-card {
    background: var(--card);
    border-radius: var(--radius);
    padding: 24px 26px;
    box-shadow: var(--shadow);
  }

  .chart-card.full { grid-column: 1 / -1; }

  .chart-title    { font-size: .93rem; font-weight: 700; margin-bottom: 2px; }
  .chart-subtitle { font-size: .78rem; color: var(--muted); margin-bottom: 20px; }

  .chart-wrap { position: relative; cursor: pointer; }

  .legend {
    display: flex; gap: 18px;
    margin-top: 14px;
    font-size: .78rem; color: var(--muted);
  }
  .legend-item { display: flex; align-items: center; gap: 6px; }
  .legend-dot  { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; }

  /* â”€â”€ Drill-down modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #drill-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.45);
    z-index: 100;
    align-items: flex-start;
    justify-content: center;
    padding: 40px 20px;
    overflow-y: auto;
  }
  #drill-overlay.open { display: flex; }

  .drill-panel {
    background: var(--card);
    border-radius: 16px;
    width: 100%;
    max-width: 960px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.18);
    overflow: hidden;
    animation: slideUp .25s ease-out;
  }
  @keyframes slideUp {
    from { opacity: 0; transform: translateY(20px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  .drill-header {
    padding: 20px 24px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .drill-header h2 { font-size: 1rem; font-weight: 700; }
  .drill-count {
    font-size: .8rem;
    color: var(--muted);
    background: var(--bg);
    padding: 3px 10px;
    border-radius: 99px;
    margin-left: 10px;
  }
  .drill-close {
    background: none;
    border: 1px solid var(--border);
    border-radius: 8px;
    width: 32px; height: 32px;
    font-size: 1.1rem;
    cursor: pointer;
    color: var(--muted);
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .drill-close:hover { background: var(--bg); }

  .drill-body {
    max-height: 65vh;
    overflow-y: auto;
  }

  .drill-table {
    width: 100%;
    border-collapse: collapse;
    font-size: .82rem;
  }
  .drill-table thead { position: sticky; top: 0; background: var(--card); z-index: 2; }
  .drill-table th {
    text-align: left;
    padding: 10px 14px;
    font-weight: 600;
    font-size: .72rem;
    text-transform: uppercase;
    letter-spacing: .05em;
    color: var(--muted);
    border-bottom: 2px solid var(--border);
    cursor: pointer;
    user-select: none;
    white-space: nowrap;
  }
  .drill-table th:hover { color: var(--text-d); }
  .drill-table th .sort-arrow { margin-left: 4px; font-size: .65rem; }
  .drill-table td {
    padding: 9px 14px;
    border-bottom: 1px solid #f3f4f6;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .drill-table tbody tr:hover { background: #f8f9ff; }
  .drill-table .att-yes { color: var(--primary); font-weight: 600; }
  .drill-table .att-no  { color: #d1d5db; }

  /* â”€â”€ Demo button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .demo-divider {
    display: flex;
    align-items: center;
    gap: 12px;
    margin: 18px 0 14px;
    color: rgba(255,255,255,0.30);
    font-size: .75rem;
  }
  .demo-divider::before,
  .demo-divider::after {
    content: "";
    flex: 1;
    height: 1px;
    background: rgba(255,255,255,0.12);
  }

  .btn-demo {
    width: 100%;
    padding: 12px 20px;
    background: rgba(255,255,255,0.06);
    border: 1px dashed rgba(255,255,255,0.22);
    border-radius: 14px;
    color: rgba(255,255,255,0.55);
    font-size: .85rem;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    letter-spacing: .01em;
    transition: background 200ms ease, color 200ms ease, border-color 200ms ease;
  }
  .btn-demo:hover {
    background: rgba(255,255,255,0.12);
    color: rgba(255,255,255,0.80);
    border-color: rgba(255,255,255,0.35);
  }
  .btn-demo:active { transform: scale(0.98); }
  .btn-demo-icon { font-size: .9rem; opacity: .7; }

  /* â”€â”€ Section dividers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .section-divider {
    display: flex;
    align-items: center;
    gap: 14px;
    margin: 10px 0 4px;
  }
  .section-divider::before,
  .section-divider::after {
    content: "";
    flex: 1;
    height: 1px;
    background: var(--border);
  }
  .section-label-inline {
    font-size: .72rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .1em;
    color: var(--muted);
    white-space: nowrap;
    padding: 0 4px;
  }

  /* â”€â”€ Engagement banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .engagement-stat-banner {
    display: flex;
    gap: 14px;
    flex-wrap: wrap;
    margin-bottom: 18px;
  }
  .eng-pill {
    background: var(--bg);
    border-radius: 12px;
    padding: 10px 18px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    min-width: 80px;
  }
  .eng-pill-value {
    font-size: 1.5rem;
    font-weight: 800;
    line-height: 1.1;
    color: var(--primary);
  }
  .eng-pill-label {
    font-size: .7rem;
    color: var(--muted);
    text-align: center;
  }

  /* â”€â”€ Asymmetric 2-column grid (1/3 + 2/3) â”€â”€ */
  .charts-grid-2-3 {
    grid-template-columns: 1fr 2fr;
  }

  /* â”€â”€ Tab bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .tab-bar {
    display: flex;
    gap: 4px;
    padding: 6px;
    background: var(--bg);
    border-radius: 14px;
    margin: 0 32px 0;
    position: sticky;
    top: 60px;
    z-index: 19;
  }
  .tab-btn {
    flex: 1;
    padding: 10px 18px;
    border: none;
    border-radius: 10px;
    background: transparent;
    color: var(--muted);
    font-family: inherit;
    font-size: .82rem;
    font-weight: 600;
    cursor: pointer;
    transition: background .2s, color .2s, box-shadow .2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 7px;
  }
  .tab-btn:hover { background: rgba(0,0,0,0.04); color: var(--text-d); }
  .tab-btn.active {
    background: var(--card);
    color: var(--text-d);
    box-shadow: 0 1px 6px rgba(0,0,0,0.08);
  }
  .tab-icon { font-size: .95rem; }
  .tab-badge {
    font-size: .65rem;
    padding: 1px 7px;
    border-radius: 99px;
    font-weight: 700;
    line-height: 1.5;
  }
  .tab-badge.connected { background: #dcfce7; color: #15803d; }
  .tab-badge.not-connected { background: #fef3c7; color: #92400e; }

  .tab-section { display: none; }
  .tab-section.active { display: block; }

  /* â”€â”€ Slack connect prompt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .connect-prompt {
    text-align: center;
    padding: 80px 40px;
    max-width: 440px;
    margin: 0 auto;
  }
  .connect-prompt-icon { font-size: 3rem; margin-bottom: 16px; }
  .connect-prompt h2 { font-size: 1.2rem; margin-bottom: 8px; color: var(--text-d); }
  .connect-prompt p { font-size: .88rem; color: var(--muted); margin-bottom: 28px; line-height: 1.6; }
  .btn-slack {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    padding: 13px 28px;
    background: #4A154B;
    color: #fff;
    border: none;
    border-radius: 12px;
    font-family: inherit;
    font-size: .9rem;
    font-weight: 600;
    cursor: pointer;
    transition: background .2s, transform .15s;
  }
  .btn-slack:hover { background: #611f69; transform: translateY(-1px); }
  .btn-slack:active { transform: scale(0.98); }
  .btn-slack svg { width: 20px; height: 20px; }

  /* â”€â”€ Relationship cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .rel-controls {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
    margin-bottom: 18px;
  }
  .rel-sort, .rel-filter {
    padding: 7px 14px;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-family: inherit;
    font-size: .8rem;
    background: var(--card);
    color: var(--text-d);
    cursor: pointer;
  }
  .rel-cards-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    gap: 14px;
  }
  .rel-card {
    background: var(--card);
    border-radius: var(--radius);
    padding: 20px;
    box-shadow: var(--shadow);
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .rel-card-header {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .rel-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--primary);
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: .85rem;
    flex-shrink: 0;
  }
  .rel-name { font-weight: 600; font-size: .92rem; }
  .rel-email { font-size: .75rem; color: var(--muted); }
  .rel-channel-bar {
    display: flex;
    height: 8px;
    border-radius: 99px;
    overflow: hidden;
    background: var(--bg);
  }
  .rel-channel-bar .email-part { background: var(--primary); }
  .rel-channel-bar .slack-part { background: #E01E5A; }
  .rel-stats {
    display: flex;
    gap: 14px;
    flex-wrap: wrap;
  }
  .rel-stat {
    display: flex;
    flex-direction: column;
    gap: 1px;
  }
  .rel-stat-value {
    font-size: .92rem;
    font-weight: 700;
    color: var(--text-d);
  }
  .rel-stat-label {
    font-size: .68rem;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: .04em;
  }

  @media (max-width: 800px) {
    main { padding: 16px; }
    .charts-grid { grid-template-columns: 1fr; }
    .charts-grid-2-3 { grid-template-columns: 1fr; }
    .chart-card.full { grid-column: 1; }
    .drill-panel { max-width: 100%; }
    .login-card { width: 92vw; padding: 36px 24px 28px; }
    .tab-bar { margin: 0 16px; }
    .tab-btn { padding: 8px 10px; font-size: .75rem; }
    .rel-cards-grid { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<!-- â”€â”€ LOGIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="login-screen">
  <div class="glass-orb glass-orb-1"></div>
  <div class="glass-orb glass-orb-2"></div>
  <div class="glass-orb glass-orb-3"></div>

  <div class="login-card">
    <div class="login-icon">ğŸ“Š</div>
    <h1>Comms Dashboard</h1>
    <p>Analyse your email and Slack communication patterns. Connect one or both to get started.</p>

    <!-- â”€â”€ Radial time slider â”€â”€ -->
    <div class="time-slider-section">
      <div class="time-slider-label">Time range</div>
      <div class="time-slider-wrap">
        <svg id="time-slider" viewBox="0 0 240 240" width="204" height="204">
          <defs>
            <!-- Arc gradient: semi-transparent white, slightly more opaque than track -->
            <linearGradient id="arcGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%"   stop-color="rgba(255,255,255,0.60)"/>
              <stop offset="100%" stop-color="rgba(255,255,255,0.35)"/>
            </linearGradient>
            <!-- Handle: glass bubble with top-left specular highlight -->
            <radialGradient id="handleGrad" cx="35%" cy="30%" r="65%">
              <stop offset="0%"   stop-color="rgba(255,255,255,0.95)"/>
              <stop offset="60%"  stop-color="rgba(255,255,255,0.55)"/>
              <stop offset="100%" stop-color="rgba(255,255,255,0.30)"/>
            </radialGradient>
            <!-- Handle border (subtle glass edge) -->
            <radialGradient id="handleBorderGrad" cx="35%" cy="30%" r="65%">
              <stop offset="0%"   stop-color="rgba(255,255,255,0.60)"/>
              <stop offset="100%" stop-color="rgba(255,255,255,0.20)"/>
            </radialGradient>
            <!-- Soft glow on active arc -->
            <filter id="arcGlow" x="-20%" y="-20%" width="140%" height="140%">
              <feGaussianBlur in="SourceGraphic" stdDeviation="2.5" result="blur"/>
              <feMerge>
                <feMergeNode in="blur"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>

          <!-- Track ring â€” semi-transparent white -->
          <circle cx="120" cy="120" r="88"
            fill="none"
            stroke="rgba(255,255,255,0.08)"
            stroke-width="12"/>

          <!-- Subtle year markers â€” no heavy ticks, just soft labels -->
          <text x="222" y="124" fill="rgba(255,255,255,0.25)" font-size="9" font-weight="400"
            text-anchor="middle" font-family="Inter,-apple-system,BlinkMacSystemFont,sans-serif">1y</text>
          <text x="120" y="224" fill="rgba(255,255,255,0.25)" font-size="9" font-weight="400"
            text-anchor="middle" font-family="Inter,-apple-system,BlinkMacSystemFont,sans-serif">2y</text>
          <text x="18"  y="124" fill="rgba(255,255,255,0.25)" font-size="9" font-weight="400"
            text-anchor="middle" font-family="Inter,-apple-system,BlinkMacSystemFont,sans-serif">3y</text>
          <text x="120" y="17"  fill="rgba(255,255,255,0.25)" font-size="9" font-weight="400"
            text-anchor="middle" font-family="Inter,-apple-system,BlinkMacSystemFont,sans-serif">4y</text>

          <!-- Active progress arc -->
          <path id="slider-arc"
            fill="none"
            stroke="url(#arcGrad)"
            stroke-width="12"
            stroke-linecap="round"
            filter="url(#arcGlow)"/>

          <!-- Center: large spacious value -->
          <text id="slider-main" x="120" y="112"
            text-anchor="middle" dominant-baseline="middle"
            fill="var(--text-primary)"
            font-size="30" font-weight="500"
            font-family="Inter, -apple-system, BlinkMacSystemFont, sans-serif"
            letter-spacing="-0.03em">18mo</text>

          <!-- Center: secondary label -->
          <text id="slider-sub" x="120" y="138"
            text-anchor="middle" dominant-baseline="middle"
            fill="var(--text-secondary)"
            font-size="10.5" font-weight="400"
            font-family="Inter, -apple-system, BlinkMacSystemFont, sans-serif">of history</text>

          <!-- Handle: glass bubble â€” same blur+border rule as container -->
          <circle id="slider-handle" r="12"
            fill="url(#handleGrad)"
            stroke="url(#handleBorderGrad)"
            stroke-width="1.5"/>
        </svg>
      </div>
    </div>

    <div id="error-msg"></div>
    <button class="btn-primary" id="login-btn" onclick="login()">Sign in with Microsoft</button>

    <div class="demo-divider"><span>or connect</span></div>
    <button class="btn-slack" onclick="connectSlack()" style="width:100%;justify-content:center">
      <svg viewBox="0 0 24 24" fill="currentColor" style="width:18px;height:18px"><path d="M5.042 15.165a2.528 2.528 0 0 1-2.52 2.523A2.528 2.528 0 0 1 0 15.165a2.527 2.527 0 0 1 2.522-2.52h2.52v2.52zm1.271 0a2.527 2.527 0 0 1 2.521-2.52 2.527 2.527 0 0 1 2.521 2.52v6.313A2.528 2.528 0 0 1 8.834 24a2.528 2.528 0 0 1-2.521-2.522v-6.313zM8.834 5.042a2.528 2.528 0 0 1-2.521-2.52A2.528 2.528 0 0 1 8.834 0a2.528 2.528 0 0 1 2.521 2.522v2.52H8.834zm0 1.271a2.528 2.528 0 0 1 2.521 2.521 2.528 2.528 0 0 1-2.521 2.521H2.522A2.528 2.528 0 0 1 0 8.834a2.528 2.528 0 0 1 2.522-2.521h6.312zM18.956 8.834a2.528 2.528 0 0 1 2.522-2.521A2.528 2.528 0 0 1 24 8.834a2.528 2.528 0 0 1-2.522 2.521h-2.522V8.834zm-1.27 0a2.528 2.528 0 0 1-2.523 2.521 2.527 2.527 0 0 1-2.52-2.521V2.522A2.527 2.527 0 0 1 15.163 0a2.528 2.528 0 0 1 2.523 2.522v6.312zM15.163 18.956a2.528 2.528 0 0 1 2.523 2.522A2.528 2.528 0 0 1 15.163 24a2.527 2.527 0 0 1-2.52-2.522v-2.522h2.52zm0-1.27a2.527 2.527 0 0 1-2.52-2.523 2.527 2.527 0 0 1 2.52-2.52h6.315A2.528 2.528 0 0 1 24 15.163a2.528 2.528 0 0 1-2.522 2.523h-6.315z"/></svg>
      Connect Slack
    </button>
    <div class="demo-divider"><span>or</span></div>
    <button class="btn-demo" onclick="loadDemoData()">
      <span class="btn-demo-icon">âœ¦</span> Try with demo data
    </button>
  </div>
</div>

<!-- â”€â”€ LOADING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="loading-screen">
  <div class="spinner"></div>
  <div id="loading-text">Connectingâ€¦</div>
  <div class="progress-bar-wrap"><div class="progress-bar-inner" id="progress-bar"></div></div>
  <div id="loading-progress"></div>
</div>

<!-- â”€â”€ DASHBOARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="dashboard">

  <header>
    <div class="header-left">
      <span style="font-size:1.4rem">ğŸ“Š</span>
      <h1>Comms Dashboard</h1>
      <span id="account-badge"></span>
    </div>
    <button class="btn-ghost" onclick="signOut()">Sign out</button>
  </header>

  <!-- Tab bar -->
  <nav class="tab-bar" id="main-tab-bar">
    <button class="tab-btn active" data-tab="email" onclick="showTab('email')">
      <span class="tab-icon">ğŸ“§</span> Email
      <span class="tab-badge connected" id="badge-email" style="display:none">âœ“</span>
    </button>
    <button class="tab-btn" data-tab="slack" onclick="showTab('slack')">
      <span class="tab-icon">ğŸ’¬</span> Slack
      <span class="tab-badge not-connected" id="badge-slack">connect</span>
    </button>
    <button class="tab-btn" data-tab="relationships" onclick="showTab('relationships')">
      <span class="tab-icon">ğŸ¤</span> Relationships
    </button>
  </nav>

  <main>
    <!-- â•â•â• EMAIL TAB â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <section id="tab-email" class="tab-section active">

    <!-- Stats -->
    <div>
      <div class="section-label" id="overview-label">Overview</div>
      <div class="stats-grid" id="stats-grid"></div>
    </div>

    <!-- Timeline -->
    <div class="chart-card full">
      <div class="chart-title">Email Volume Over Time</div>
      <div class="chart-subtitle">Weekly totals â€” sent vs received Â· click a point to drill in</div>
      <div class="chart-wrap" style="height:240px"><canvas id="c-timeline"></canvas></div>
      <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:var(--received)"></div>Received</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--sent)"></div>Sent</div>
      </div>
    </div>

    <!-- Day of week + Hour of day -->
    <div class="charts-grid">
      <div class="chart-card">
        <div class="chart-title">Day of Week</div>
        <div class="chart-subtitle">Activity by weekday Â· click to drill in</div>
        <div class="chart-wrap" style="height:210px"><canvas id="c-dow"></canvas></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Hour of Day</div>
        <div class="chart-subtitle">When your inbox is most active Â· click to drill in</div>
        <div class="chart-wrap" style="height:210px"><canvas id="c-hod"></canvas></div>
      </div>
    </div>

    <!-- Top senders + recipients -->
    <div class="charts-grid">
      <div class="chart-card">
        <div class="chart-title">Top Senders</div>
        <div class="chart-subtitle">Who emails you most Â· click a bar to see emails</div>
        <div class="chart-wrap" style="height:280px"><canvas id="c-senders"></canvas></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Top Recipients</div>
        <div class="chart-subtitle">Who you email most Â· click a bar to see emails</div>
        <div class="chart-wrap" style="height:280px"><canvas id="c-recipients"></canvas></div>
      </div>
    </div>

    <!-- Response time + Read rate -->
    <div class="charts-grid">
      <div class="chart-card">
        <div class="chart-title">Response Times</div>
        <div class="chart-subtitle">How quickly you reply Â· click a bucket to see emails</div>
        <div class="chart-wrap" style="height:210px"><canvas id="c-response"></canvas></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Monthly Read Rate</div>
        <div class="chart-subtitle">% of received emails you opened Â· click to drill in</div>
        <div class="chart-wrap" style="height:210px"><canvas id="c-readrate"></canvas></div>
      </div>
    </div>

    <!-- Attachment rate -->
    <div class="chart-card full">
      <div class="chart-title">Emails with Attachments</div>
      <div class="chart-subtitle">Monthly count of messages with file attachments Â· click to drill in</div>
      <div class="chart-wrap" style="height:200px"><canvas id="c-attachments"></canvas></div>
    </div>

    <!-- â”€â”€ ENGAGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div class="section-divider">
      <span class="section-label-inline">Engagement Analytics</span>
    </div>

    <!-- Engagement score stat + chart -->
    <div class="chart-card full">
      <div class="chart-title">Engagement Score Over Time</div>
      <div class="chart-subtitle">Composite monthly score: reply rate Â· response speed Â· email initiation Â· network breadth</div>
      <div id="engagement-stat" class="engagement-stat-banner"></div>
      <div class="chart-wrap" style="height:220px"><canvas id="c-engagement"></canvas></div>
    </div>

    <!-- Task classification: doughnut + trend -->
    <div class="charts-grid charts-grid-2-3">
      <div class="chart-card">
        <div class="chart-title">Task Classification</div>
        <div class="chart-subtitle">Subject-line keyword categories Â· click a segment</div>
        <div class="chart-wrap" style="height:260px"><canvas id="c-tasks"></canvas></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Category Trend Over Time</div>
        <div class="chart-subtitle">Monthly stacked breakdown Â· click a column</div>
        <div class="chart-wrap" style="height:260px"><canvas id="c-task-trend"></canvas></div>
      </div>
    </div>

    <!-- â”€â”€ THREAD ANALYTICS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div class="section-divider">
      <span class="section-label-inline">Thread Analytics</span>
    </div>

    <div class="charts-grid">
      <div class="chart-card">
        <div class="chart-title">Thread Depth Distribution</div>
        <div class="chart-subtitle">How many messages per conversation</div>
        <div class="chart-wrap" style="height:220px"><canvas id="c-thread-depth"></canvas></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Participants per Thread</div>
        <div class="chart-subtitle">Group size distribution across conversations</div>
        <div class="chart-wrap" style="height:220px"><canvas id="c-participants"></canvas></div>
      </div>
    </div>

    <!-- â”€â”€ TRENDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div class="section-divider">
      <span class="section-label-inline">Volume &amp; Trend</span>
    </div>

    <div class="charts-grid">
      <div class="chart-card">
        <div class="chart-title">Average Email Length</div>
        <div class="chart-subtitle">Estimated word count per message (sent vs received)</div>
        <div class="chart-wrap" style="height:210px"><canvas id="c-email-length"></canvas></div>
        <div class="legend">
          <div class="legend-item"><div class="legend-dot" style="background:var(--received)"></div>Received</div>
          <div class="legend-item"><div class="legend-dot" style="background:var(--sent)"></div>Sent</div>
        </div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Unique Stakeholders per Month</div>
        <div class="chart-subtitle">Distinct people in your inbox each month</div>
        <div class="chart-wrap" style="height:210px"><canvas id="c-stakeholders"></canvas></div>
      </div>
    </div>

    <div class="chart-card full">
      <div class="chart-title">Monthly Average Response Time</div>
      <div class="chart-subtitle">How quickly you replied to emails each month (hours)</div>
      <div class="chart-wrap" style="height:200px"><canvas id="c-response-trend"></canvas></div>
    </div>

    <!-- â”€â”€ CONTACT TRENDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div class="section-divider">
      <span class="section-label-inline">Contact Trends</span>
    </div>

    <div class="chart-card full">
      <div class="chart-title">Top Senders Over Time</div>
      <div class="chart-subtitle">Monthly email volume from your most frequent senders Â· click a name to drill in</div>
      <div class="chart-wrap" style="height:240px"><canvas id="c-senders-trend"></canvas></div>
    </div>

    <div class="chart-card full">
      <div class="chart-title">Top Recipients Over Time</div>
      <div class="chart-subtitle">Monthly email volume to your most frequent recipients Â· click a name to drill in</div>
      <div class="chart-wrap" style="height:240px"><canvas id="c-recipients-trend"></canvas></div>
    </div>

    </section><!-- /tab-email -->

    <!-- â•â•â• SLACK TAB â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <section id="tab-slack" class="tab-section">

      <!-- Connect prompt (shown when Slack not connected) -->
      <div id="slack-connect-prompt" class="connect-prompt">
        <div class="connect-prompt-icon">ğŸ’¬</div>
        <h2>Connect your Slack workspace</h2>
        <p>Analyse your Slack messaging patterns â€” message volume, response times, channel activity, and more.</p>
        <button class="btn-slack" onclick="connectSlack()">
          <svg viewBox="0 0 24 24" fill="currentColor"><path d="M5.042 15.165a2.528 2.528 0 0 1-2.52 2.523A2.528 2.528 0 0 1 0 15.165a2.527 2.527 0 0 1 2.522-2.52h2.52v2.52zm1.271 0a2.527 2.527 0 0 1 2.521-2.52 2.527 2.527 0 0 1 2.521 2.52v6.313A2.528 2.528 0 0 1 8.834 24a2.528 2.528 0 0 1-2.521-2.522v-6.313zM8.834 5.042a2.528 2.528 0 0 1-2.521-2.52A2.528 2.528 0 0 1 8.834 0a2.528 2.528 0 0 1 2.521 2.522v2.52H8.834zm0 1.271a2.528 2.528 0 0 1 2.521 2.521 2.528 2.528 0 0 1-2.521 2.521H2.522A2.528 2.528 0 0 1 0 8.834a2.528 2.528 0 0 1 2.522-2.521h6.312zM18.956 8.834a2.528 2.528 0 0 1 2.522-2.521A2.528 2.528 0 0 1 24 8.834a2.528 2.528 0 0 1-2.522 2.521h-2.522V8.834zm-1.27 0a2.528 2.528 0 0 1-2.523 2.521 2.527 2.527 0 0 1-2.52-2.521V2.522A2.527 2.527 0 0 1 15.163 0a2.528 2.528 0 0 1 2.523 2.522v6.312zM15.163 18.956a2.528 2.528 0 0 1 2.523 2.522A2.528 2.528 0 0 1 15.163 24a2.527 2.527 0 0 1-2.52-2.522v-2.522h2.52zm0-1.27a2.527 2.527 0 0 1-2.52-2.523 2.527 2.527 0 0 1 2.52-2.52h6.315A2.528 2.528 0 0 1 24 15.163a2.528 2.528 0 0 1-2.522 2.523h-6.315z"/></svg>
          Connect Slack
        </button>
      </div>

      <!-- Charts (shown when Slack connected or demo mode) -->
      <div id="slack-charts" style="display:none">
        <div>
          <div class="section-label" id="slack-overview-label">Slack Overview</div>
          <div class="stats-grid" id="slack-stats-grid"></div>
        </div>

        <div class="chart-card full">
          <div class="chart-title">Message Volume Over Time</div>
          <div class="chart-subtitle">Weekly Slack messages â€” sent vs received</div>
          <div class="chart-wrap" style="height:240px"><canvas id="c-slack-volume"></canvas></div>
          <div class="legend">
            <div class="legend-item"><div class="legend-dot" style="background:#5b6af9"></div>Received</div>
            <div class="legend-item"><div class="legend-dot" style="background:#f97066"></div>Sent</div>
          </div>
        </div>

        <div class="charts-grid">
          <div class="chart-card">
            <div class="chart-title">Channel Distribution</div>
            <div class="chart-subtitle">Top 10 most active channels</div>
            <div class="chart-wrap" style="height:260px"><canvas id="c-slack-channels"></canvas></div>
          </div>
          <div class="chart-card">
            <div class="chart-title">Top DM Contacts</div>
            <div class="chart-subtitle">People you message most</div>
            <div class="chart-wrap" style="height:260px"><canvas id="c-slack-dm-contacts"></canvas></div>
          </div>
        </div>

        <div class="charts-grid">
          <div class="chart-card">
            <div class="chart-title">Response Times</div>
            <div class="chart-subtitle">How quickly you reply in DMs</div>
            <div class="chart-wrap" style="height:210px"><canvas id="c-slack-response"></canvas></div>
          </div>
          <div class="chart-card">
            <div class="chart-title">Reaction Analytics</div>
            <div class="chart-subtitle">Most used emoji reactions</div>
            <div class="chart-wrap" style="height:210px"><canvas id="c-slack-reactions"></canvas></div>
          </div>
        </div>

        <div class="chart-card full">
          <div class="chart-title">Active Hours</div>
          <div class="chart-subtitle">When you're most active on Slack (day Ã— hour)</div>
          <div class="chart-wrap" style="height:220px"><canvas id="c-slack-heatmap"></canvas></div>
        </div>

        <div class="charts-grid">
          <div class="chart-card">
            <div class="chart-title">DM vs Channel vs Group</div>
            <div class="chart-subtitle">Message distribution by type</div>
            <div class="chart-wrap" style="height:220px"><canvas id="c-slack-ratio"></canvas></div>
          </div>
          <div class="chart-card">
            <div class="chart-title">Message Length Trend</div>
            <div class="chart-subtitle">Average words per message over time</div>
            <div class="chart-wrap" style="height:220px"><canvas id="c-slack-length"></canvas></div>
          </div>
        </div>
      </div>

    </section><!-- /tab-slack -->

    <!-- â•â•â• RELATIONSHIPS TAB â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <section id="tab-relationships" class="tab-section">

      <!-- Prompt when missing data -->
      <div id="rel-connect-prompt" class="connect-prompt">
        <div class="connect-prompt-icon">ğŸ¤</div>
        <h2>Cross-channel relationships</h2>
        <p>Connect both your email and Slack to see how you communicate with each person across channels, or try demo data.</p>
        <button class="btn-slack" onclick="loadDemoData()" style="background:var(--primary)">
          <span>âœ¦</span> Load demo data
        </button>
      </div>

      <!-- Relationship content (shown when both connected or demo) -->
      <div id="rel-content" style="display:none">

        <!-- Aggregate cross-channel charts -->
        <div class="section-divider">
          <span class="section-label-inline">Cross-channel Overview</span>
        </div>

        <div class="charts-grid">
          <div class="chart-card">
            <div class="chart-title">Channel Preference</div>
            <div class="chart-subtitle">How contacts split across email vs Slack</div>
            <div class="chart-wrap" style="height:240px"><canvas id="c-rel-preference"></canvas></div>
          </div>
          <div class="chart-card">
            <div class="chart-title">Engagement Score</div>
            <div class="chart-subtitle">Combined engagement across both platforms</div>
            <div class="chart-wrap" style="height:240px"><canvas id="c-rel-engagement"></canvas></div>
          </div>
        </div>

        <div class="section-divider">
          <span class="section-label-inline">Per-person Relationships</span>
        </div>

        <div class="rel-controls">
          <select class="rel-sort" id="rel-sort" onchange="renderRelCards()">
            <option value="total">Sort: Total interactions</option>
            <option value="recent">Sort: Most recent</option>
            <option value="response">Sort: Response time</option>
          </select>
          <select class="rel-filter" id="rel-filter" onchange="renderRelCards()">
            <option value="all">Show: All contacts</option>
            <option value="both">Both channels</option>
            <option value="email-only">Email only</option>
            <option value="slack-only">Slack only</option>
          </select>
        </div>

        <div class="rel-cards-grid" id="rel-cards-grid"></div>
      </div>

    </section><!-- /tab-relationships -->

  </main>
</div><!-- /dashboard -->

<!-- â”€â”€ DRILL-DOWN MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="drill-overlay" onclick="if(event.target===this)closeDrill()">
  <div class="drill-panel">
    <div class="drill-header">
      <div style="display:flex;align-items:center">
        <h2 id="drill-title">Emails</h2>
        <span class="drill-count" id="drill-count"></span>
      </div>
      <button class="drill-close" onclick="closeDrill()">âœ•</button>
    </div>
    <div class="drill-body">
      <table class="drill-table">
        <thead>
          <tr>
            <th onclick="sortDrill('date')">Date <span class="sort-arrow" id="sort-date">â–¼</span></th>
            <th onclick="sortDrill('from')">From <span class="sort-arrow" id="sort-from"></span></th>
            <th onclick="sortDrill('to')">To <span class="sort-arrow" id="sort-to"></span></th>
            <th onclick="sortDrill('subject')">Subject <span class="sort-arrow" id="sort-subject"></span></th>
            <th onclick="sortDrill('attachment')">Attachment <span class="sort-arrow" id="sort-attachment"></span></th>
          </tr>
        </thead>
        <tbody id="drill-tbody"></tbody>
      </table>
    </div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEMO DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function generateDemoData() {
  const ME_EMAIL = "csongor@cambri.io";
  const ME_NAME  = "Csongor";

  // Deterministic seeded RNG for reproducible charts
  let seed = 7919;
  const rng  = () => { seed = (seed * 1664525 + 1013904223) >>> 0; return seed / 0x100000000; };
  const pick = arr => arr[Math.floor(rng() * arr.length)];
  const rInt = (lo, hi) => lo + Math.floor(rng() * (hi - lo + 1));
  const rBool = (p = 0.5) => rng() < p;

  const C = [
    // Inner circle
    { name:"Sarah Chen",       email:"sarah.chen@acmecorp.io",        freq:1.00 },
    { name:"Marcus Webb",      email:"marcus@nexuspartners.com",       freq:0.88 },
    { name:"Priya Sharma",     email:"p.sharma@acmecorp.io",          freq:0.80 },
    { name:"James O'Brien",    email:"james@bridgevc.com",            freq:0.72 },
    { name:"Lena Fischer",     email:"l.fischer@acmecorp.io",         freq:0.65 },
    // Regular
    { name:"Tom Bradley",      email:"t.bradley@stellartech.io",      freq:0.48 },
    { name:"Aisha Osei",       email:"a.osei@globalstrategy.com",     freq:0.42 },
    { name:"David Park",       email:"d.park@acmecorp.io",            freq:0.38 },
    { name:"Emma Thornton",    email:"e.thornton@counsellors.co",     freq:0.36 },
    { name:"Rafael Santos",    email:"r.santos@launchbase.io",        freq:0.30 },
    { name:"Yuki Tanaka",      email:"y.tanaka@globalstrategy.com",   freq:0.26 },
    { name:"Hannah Mueller",   email:"h.mueller@nexuspartners.com",   freq:0.24 },
    // Occasional
    { name:"Ben Foster",       email:"ben@fostervc.com",              freq:0.14 },
    { name:"Clara Diaz",       email:"c.diaz@launchbase.io",          freq:0.12 },
    { name:"Oliver Wright",    email:"o.wright@acmecorp.io",          freq:0.10 },
    { name:"Nadia Ali",        email:"nadia@globalstrategy.com",      freq:0.10 },
    { name:"Chris Barton",     email:"c.barton@stellartech.io",       freq:0.08 },
    { name:"Fatima Hassan",    email:"f.hassan@counsellors.co",       freq:0.08 },
    { name:"Luke Peterson",    email:"l.peterson@nexuspartners.com",  freq:0.07 },
    { name:"Anna Kowalski",    email:"a.kowalski@acmecorp.io",        freq:0.07 },
    { name:"Sam Torres",       email:"s.torres@launchbase.io",        freq:0.06 },
    { name:"Mei Lin",          email:"mei.lin@globalstrategy.com",    freq:0.06 },
    { name:"Jack Harrison",    email:"j.harrison@fostervc.com",       freq:0.05 },
    { name:"Bea Dupont",       email:"b.dupont@counsellors.co",       freq:0.05 },
    { name:"Arjun Mehta",      email:"a.mehta@bridgevc.com",          freq:0.04 },
  ];

  const SUBJ = {
    "Sales":          ["Proposal â€” {co} Q{q}","Follow-up: {name} <> {co}","{co} deal status","Intro: {name} from {co}","Pricing update â€” {co}","Pipeline review Q{q}","{co} contract renewal","Customer success: {co}"],
    "Fundraising":    ["Series A â€” investor update","Intro: {name} ({vc})","Cap table model","{vc} term sheet review","Monthly investor update","Due diligence checklist","Lead investor: {name}","Fund close â€” final steps"],
    "Hiring":         ["Interview: {name} â€” {role}","Offer letter â€” {name}","Hiring pipeline update","Candidate feedback: {name}","Reference check â€” {name}","New role: {role}","{name} â€” start date","Recruiter brief: {role}"],
    "Finance":        ["Invoice #{n} â€” {mo}","Q{q} budget review","Expense report â€” {mo}","Monthly P&L â€” {mo}","Payment #{n} confirmed","{mo} payroll","FY{yr} projections","A/P queue update"],
    "Legal":          ["NDA â€” {co}","Contract review â€” {co}","IP assignment â€” {name}","T&Cs update","Employment agreement â€” {name}","SHA revision","Compliance update â€” {mo}","DPA â€” {co}"],
    "1:1 / Sync":     ["1:1 agenda â€” {name}","Weekly sync with {name}","Catch-up re: {topic}","Quick chat?","Our call tomorrow","{topic} â€” let's align","Coffee â€” {name}","Monthly 1:1 â€” {name}"],
    "Internal":       ["All-hands recap â€” {mo}","Company update â€” {mo}","Team announcement","Q{q} OKR review","Culture survey results","Office hours â€” {mo}","{dept} offsite","Internal newsletter"],
    "Project / Other":["Project {proj}: status","Sprint {n} planning","{proj} launch prep","Feature request: {feature}","Bug triage â€” {proj}","{proj} roadmap Q{q}","Milestone reached","User research findings"],
  };

  const CAT_W = [
    ["Internal",0.27],["Sales",0.20],["1:1 / Sync",0.14],["Project / Other",0.14],
    ["Finance",0.09],["Hiring",0.08],["Legal",0.05],["Fundraising",0.03],
  ];
  function pickCat() {
    let r = rng(), cum = 0;
    for (const [cat,w] of CAT_W) { cum += w; if (r < cum) return cat; }
    return "Project / Other";
  }

  const FILL = {
    cos:     ["Acme Corp","TechVentures","GlobalTech","LaunchBase","Stellar IO","Nexus","BridgeCo"],
    vcs:     ["Sequoia","a16z","Accel","Index","Northzone","Tiger","Benchmark"],
    roles:   ["Head of Sales","Sr Engineer","Marketing Lead","Product Manager","Data Analyst","CTO","CFO"],
    projs:   ["Phoenix","Atlas","Nebula","Apex","Horizon","Forge","Nova"],
    features:["dark mode","SSO","export API","notifications","bulk upload","webhooks"],
    topics:  ["roadmap","Q3 targets","budget","team structure","launch timeline","strategy"],
    depts:   ["Engineering","Marketing","Sales","Finance","Product","Design"],
    months:  ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
  };

  function mkSubject(cat) {
    const tpl = pick(SUBJ[cat]);
    const now  = new Date();
    return tpl
      .replace("{name}",    pick(C).name.split(" ")[0])
      .replace("{co}",      pick(FILL.cos))
      .replace("{vc}",      pick(FILL.vcs))
      .replace("{role}",    pick(FILL.roles))
      .replace("{proj}",    pick(FILL.projs))
      .replace("{feature}", pick(FILL.features))
      .replace("{topic}",   pick(FILL.topics))
      .replace("{dept}",    pick(FILL.depts))
      .replace("{mo}",      FILL.months[now.getMonth()])
      .replace("{yr}",      String(now.getFullYear()).slice(-2))
      .replace("{q}",       String(Math.ceil((now.getMonth()+1)/3)))
      .replace("{n}",       String(rInt(100,999)));
  }

  const PREVIEWS = [
    "Following up on our conversation from last week. I wanted to share the updated documents and get your thoughts before we proceed with the next steps.",
    "Quick note â€” I've reviewed the materials and have a few questions. Can we find 30 minutes to connect this week? I think it's worth aligning before we move forward.",
    "Thanks for the intro! I've had a chance to look through the details and I think there's a strong fit here. Happy to discuss further at your convenience.",
    "Just wanted to confirm we're still on for tomorrow's call. Let me know if anything changes on your end and we can reschedule if needed.",
    "I've attached the revised version based on your feedback. Please let me know if this looks good or if you'd like any further changes before we finalize.",
    "Great news â€” the team has signed off on this. I'll coordinate next steps on our end and keep you in the loop as things progress over the coming days.",
    "Circling back on this thread. I know we've all been busy but wanted to make sure this doesn't fall through the cracks given the timeline we discussed.",
    "Please find attached the document you requested. Let me know if you need anything else from my side or if there are outstanding questions I can address.",
    "Quick update: we've made progress on this since we last spoke. I'll share more context in our next sync but wanted to flag the movement now.",
    "Thanks for your patience on this. I've been working through the details carefully and wanted to give you a proper answer rather than something rushed.",
    "Wanted to loop you in on this thread as it's become directly relevant to the work we discussed. Feel free to jump in with any thoughts or questions.",
    "This is looking solid overall. A few minor items to resolve but nothing blocking progress. Let's aim to finalize by end of week if possible.",
    "Following up on the open items from our last meeting. I've made progress on most of them â€” see my notes below for the full picture.",
    "Just a heads up that there's been a slight delay on this end. Nothing major, wanted to keep you informed so there are no surprises down the line.",
    "I've shared this with the relevant stakeholders on our side and we're aligned. Currently waiting on final sign-off from the finance team before proceeding.",
    "Really appreciate you moving quickly on this. Looking forward to getting started and making meaningful progress together on this initiative.",
    "A few things I'd like to discuss before we finalize. I'll prepare a brief agenda and send it over the day before so we can make the most of our time.",
    "This got a bit more complex than initially expected, but I think we have a solid path forward now. Let me walk you through my thinking when we connect.",
    "Good timing on this â€” we were just discussing something very similar internally. There may be a real opportunity here worth exploring together.",
    "Everything looks good from our side. Just need your signature on the attached and we're ready to move forward and kick things off officially.",
  ];

  const received = [], sent = [];
  let msgId = 1, convId = 1;
  const now = new Date();

  // Month busyness index (0=Jan â€¦ 11=Dec)
  const BUSY = [1.15,1.10,1.08,0.95,0.90,0.82,0.72,0.80,0.97,1.12,1.22,0.68];

  for (let m = 0; m < 12; m++) {
    const mDate  = new Date(now.getFullYear(), now.getMonth() - 11 + m, 1);
    const daysInM = new Date(mDate.getFullYear(), mDate.getMonth() + 1, 0).getDate();
    const busy   = BUSY[mDate.getMonth()];

    for (const ct of C) {
      const count = Math.max(0, Math.round(ct.freq * 14 * busy) + rInt(-1, 1));
      for (let i = 0; i < count; i++) {
        let day = rInt(1, daysInM);
        const dow = new Date(mDate.getFullYear(), mDate.getMonth(), day).getDay();
        if ((dow === 0 || dow === 6) && rBool(0.72)) continue; // skip most weekends
        const hour = rBool(0.72) ? rInt(8,18) : rInt(6,22);
        const ts   = new Date(mDate.getFullYear(), mDate.getMonth(), day, hour, rInt(0,59), 0);
        if (ts > now) continue;

        const cat  = pickCat();
        const subj = mkSubject(cat);
        const cId  = "conv_" + convId;
        const ccList = rBool(0.18) ? [{ emailAddress: { name: pick(C.filter(x=>x!==ct)).name, address: pick(C.filter(x=>x!==ct)).email } }] : [];

        received.push({
          id: "r"+msgId++, receivedDateTime: ts.toISOString(),
          from: { emailAddress: { name: ct.name, address: ct.email } },
          toRecipients: [{ emailAddress: { name: ME_NAME, address: ME_EMAIL } }],
          ccRecipients: ccList, subject: subj, conversationId: cId,
          isRead: rBool(0.84), hasAttachments: rBool(0.17), bodyPreview: pick(PREVIEWS),
        });

        // Reply (builds thread + response-time data)
        if (rBool(0.46)) {
          const delayMin = rInt(15, 48*60);
          const rTs = new Date(ts.getTime() + delayMin*60000);
          if (rTs <= now) {
            sent.push({
              id: "s"+msgId++, sentDateTime: rTs.toISOString(),
              from: { emailAddress: { name: ME_NAME, address: ME_EMAIL } },
              toRecipients: [{ emailAddress: { name: ct.name, address: ct.email } }],
              ccRecipients: ccList, subject: "Re: "+subj, conversationId: cId,
              hasAttachments: rBool(0.08), bodyPreview: pick(PREVIEWS),
            });
            // Their follow-up reply
            if (rBool(0.28)) {
              const r2Ts = new Date(rTs.getTime() + rInt(30,6*60)*60000);
              if (r2Ts <= now) {
                received.push({
                  id: "r"+msgId++, receivedDateTime: r2Ts.toISOString(),
                  from: { emailAddress: { name: ct.name, address: ct.email } },
                  toRecipients: [{ emailAddress: { name: ME_NAME, address: ME_EMAIL } }],
                  ccRecipients: ccList, subject: "Re: "+subj, conversationId: cId,
                  isRead: rBool(0.88), hasAttachments: rBool(0.10), bodyPreview: pick(PREVIEWS),
                });
              }
            }
          }
        }

        // Proactive sent emails (not replies)
        if (rBool(0.14)) {
          const sDay = rInt(1, daysInM);
          const sTs  = new Date(mDate.getFullYear(), mDate.getMonth(), sDay, rBool(0.75)?rInt(8,18):rInt(6,22), rInt(0,59), 0);
          if (sTs <= now) {
            sent.push({
              id: "s"+msgId++, sentDateTime: sTs.toISOString(),
              from: { emailAddress: { name: ME_NAME, address: ME_EMAIL } },
              toRecipients: [{ emailAddress: { name: ct.name, address: ct.email } }],
              ccRecipients: [], subject: mkSubject(cat),
              conversationId: "conv_"+(convId+5000),
              hasAttachments: rBool(0.12), bodyPreview: pick(PREVIEWS),
            });
          }
        }

        convId++;
      }
    }
  }

  return { received, sent };
}

function generateSlackDemoData() {
  // Use a different seed so Slack data differs from email but is reproducible
  let seed = 4219;
  const rng  = () => { seed = (seed * 1664525 + 1013904223) >>> 0; return seed / 0x100000000; };
  const pick = arr => arr[Math.floor(rng() * arr.length)];
  const rInt = (lo, hi) => lo + Math.floor(rng() * (hi - lo + 1));
  const rBool = (p = 0.5) => rng() < p;

  const ME_ID = "U_DEMO_ME";
  const ME_NAME = "Csongor";

  // Slack users â€” ~60% overlap with email contacts
  const slackUsers = [
    { id:"U001", real_name:"Sarah Chen",     profile:{email:"sarah.chen@acmecorp.io"} },
    { id:"U002", real_name:"Marcus Webb",     profile:{email:"marcus@nexuspartners.com"} },
    { id:"U003", real_name:"Priya Sharma",    profile:{email:"p.sharma@acmecorp.io"} },
    { id:"U004", real_name:"James O'Brien",   profile:{email:"james@bridgevc.com"} },
    { id:"U005", real_name:"Lena Fischer",    profile:{email:"l.fischer@acmecorp.io"} },
    { id:"U006", real_name:"Tom Bradley",     profile:{email:"t.bradley@stellartech.io"} },
    { id:"U007", real_name:"Aisha Osei",      profile:{email:"a.osei@globalstrategy.com"} },
    { id:"U008", real_name:"David Park",      profile:{email:"d.park@acmecorp.io"} },
    // Slack-only contacts
    { id:"U009", real_name:"Kyle Nguyen",     profile:{email:"k.nguyen@acmecorp.io"} },
    { id:"U010", real_name:"Zara Mitchell",   profile:{email:"z.mitchell@acmecorp.io"} },
    { id:"U011", real_name:"Rio Tanaka",      profile:{email:"r.tanaka@stellartech.io"} },
    { id:"U012", real_name:"Elena Volkov",    profile:{email:"e.volkov@acmecorp.io"} },
    { id:"U013", real_name:"Sam Torres",      profile:{email:"s.torres@launchbase.io"} },
    { id:"U014", real_name:"Nina Patel",      profile:{email:"n.patel@acmecorp.io"} },
    { id:"U015", real_name:"Jake Foster",     profile:{email:"j.foster@fostervc.com"} },
  ];

  const userMap = {};
  slackUsers.forEach(u => { userMap[u.id] = u.real_name; });
  userMap[ME_ID] = ME_NAME;

  // Channels
  const channels = [
    { id:"C001", name:"general",        is_im:false, is_mpim:false, is_private:false },
    { id:"C002", name:"product",        is_im:false, is_mpim:false, is_private:false },
    { id:"C003", name:"engineering",    is_im:false, is_mpim:false, is_private:false },
    { id:"C004", name:"sales",          is_im:false, is_mpim:false, is_private:false },
    { id:"C005", name:"random",         is_im:false, is_mpim:false, is_private:false },
    { id:"C006", name:"leadership",     is_im:false, is_mpim:false, is_private:true },
    { id:"C007", name:"hiring",         is_im:false, is_mpim:false, is_private:true },
  ];

  // DM channels with users
  const dmChannels = slackUsers.map((u, i) => ({
    id: `D${String(i+1).padStart(3,"0")}`, name: null, is_im: true, is_mpim: false, is_private: false, user: u.id
  }));

  const allChannels = [...channels, ...dmChannels];

  const EMOJIS = ["+1","heart","fire","rocket","eyes","100","tada","thinking_face","pray","clap","muscle","star","check","wave","brain"];
  const TEXTS = [
    "Sounds good, let's do it",
    "Can you share the latest version?",
    "I'll take a look and get back to you",
    "Thanks for the update!",
    "Let's sync on this tomorrow",
    "Great work on this",
    "I have a few questions about the approach",
    "Agreed, let's move forward",
    "Can we schedule a quick call?",
    "I'll handle this",
    "Just pushed the changes",
    "LGTM, ship it",
    "Need to revisit this after the release",
    "cc @channel for visibility",
    "Here's the doc: docs.google.com/...",
    "Running a bit behind, will update by EOD",
    "Blocked on this â€” need input from product",
    "Happy to help with that",
    "Nice catch, fixing now",
    "Let me check with the team",
  ];

  const messages = [];
  const now = Date.now() / 1000;
  const BUSY = [1.15,1.10,1.08,0.95,0.90,0.82,0.72,0.80,0.97,1.12,1.22,0.68];
  const nowDate = new Date();

  // Channel frequency weights
  const chFreq = { C001:0.15, C002:0.20, C003:0.18, C004:0.10, C005:0.08, C006:0.06, C007:0.04 };
  // DM frequency tied to user
  const dmFreq = [0.12,0.10,0.08,0.07,0.06,0.05,0.04,0.04,0.03,0.03,0.02,0.02,0.02,0.01,0.01];

  for (let m = 0; m < 12; m++) {
    const mDate = new Date(nowDate.getFullYear(), nowDate.getMonth() - 11 + m, 1);
    const daysInM = new Date(mDate.getFullYear(), mDate.getMonth() + 1, 0).getDate();
    const busy = BUSY[mDate.getMonth()];

    // Public/private channel messages
    channels.forEach(ch => {
      const freq = chFreq[ch.id] || 0.05;
      const count = Math.max(0, Math.round(freq * 180 * busy) + rInt(-3, 3));
      for (let i = 0; i < count; i++) {
        const day = rInt(1, daysInM);
        const d = new Date(mDate.getFullYear(), mDate.getMonth(), day);
        if ((d.getDay() === 0 || d.getDay() === 6) && rBool(0.8)) continue;
        const hour = rBool(0.75) ? rInt(9, 18) : rInt(7, 22);
        const ts = new Date(mDate.getFullYear(), mDate.getMonth(), day, hour, rInt(0,59), rInt(0,59));
        if (ts.getTime()/1000 > now) continue;

        const isMine = rBool(0.25);
        const userId = isMine ? ME_ID : pick(slackUsers).id;
        const reactions = rBool(0.15) ? [{ name: pick(EMOJIS), count: rInt(1,4) }] : [];
        if (rBool(0.08)) reactions.push({ name: pick(EMOJIS), count: rInt(1,2) });

        messages.push({
          ts: ts.getTime() / 1000,
          userId,
          userName: userMap[userId],
          channelId: ch.id,
          channelName: ch.name,
          channelType: ch.is_private ? "private" : "public",
          text: pick(TEXTS),
          reactions,
          threadTs: rBool(0.2) ? String(ts.getTime()/1000 - rInt(60, 3600)) : null,
          replyCount: rBool(0.12) ? rInt(1, 5) : 0,
          isReply: rBool(0.18),
        });
      }
    });

    // DM messages
    dmChannels.forEach((ch, idx) => {
      const freq = dmFreq[idx] || 0.01;
      const count = Math.max(0, Math.round(freq * 120 * busy) + rInt(-1, 1));
      for (let i = 0; i < count; i++) {
        const day = rInt(1, daysInM);
        const d = new Date(mDate.getFullYear(), mDate.getMonth(), day);
        if ((d.getDay() === 0 || d.getDay() === 6) && rBool(0.85)) continue;
        const hour = rBool(0.7) ? rInt(9, 18) : rInt(7, 22);
        const ts = new Date(mDate.getFullYear(), mDate.getMonth(), day, hour, rInt(0,59), rInt(0,59));
        if (ts.getTime()/1000 > now) continue;

        const isMine = rBool(0.45);
        const userId = isMine ? ME_ID : ch.user;
        const reactions = rBool(0.10) ? [{ name: pick(EMOJIS), count: 1 }] : [];

        messages.push({
          ts: ts.getTime() / 1000,
          userId,
          userName: userMap[userId] || "Unknown",
          channelId: ch.id,
          channelName: `DM: ${userMap[ch.user]}`,
          channelType: "dm",
          text: pick(TEXTS) + (rBool(0.3) ? " " + pick(TEXTS.slice(0,5)) : ""),
          reactions,
          threadTs: null,
          replyCount: 0,
          isReply: false,
        });
      }
    });
  }

  return { messages, channels: allChannels, users: slackUsers, myUserId: ME_ID };
}

function loadDemoData() {
  MONTHS_BACK = 12;

  // Email demo data
  const { received, sent } = generateDemoData();
  ALL_RECEIVED = received;
  ALL_SENT     = sent;
  AUTH_STATE.microsoft = true;

  // Slack demo data
  const slackDemo = generateSlackDemoData();
  SLACK_DATA.messages  = slackDemo.messages;
  SLACK_DATA.channels  = slackDemo.channels;
  SLACK_DATA.users     = slackDemo.users;
  SLACK_DATA.myUserId  = slackDemo.myUserId;
  AUTH_STATE.slack = true;

  document.getElementById("account-badge").textContent = "Demo Mode";
  const lbl = document.getElementById("overview-label");
  if (lbl) lbl.textContent = "12-month overview";
  const slbl = document.getElementById("slack-overview-label");
  if (slbl) slbl.textContent = "12-month Slack overview";

  showScreen("dashboard");
  updateAuthBadges();
  showSlackCharts();
  showRelContent();

  renderDashboard(ALL_RECEIVED, ALL_SENT);
  renderSlackDashboard();
  buildAndRenderRelationships();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CLIENT_ID    = "52975658-2cda-4237-a140-6f4f60b5f67c";
const TENANT_ID    = "d0a04723-fdc3-4b9f-b4ca-ed07f918688a";
const REDIRECT_URI = window.location.origin;
const GRAPH        = "https://graph.microsoft.com/v1.0";

// Driven by the radial slider (default 18)
let MONTHS_BACK = 18;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL DATA STORE (populated after fetch)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let ALL_RECEIVED = [];
let ALL_SENT     = [];

// â”€â”€ Slack state â”€â”€
let AUTH_STATE   = { microsoft: false, slack: false };
let SLACK_TOKEN  = null;
let SLACK_DATA   = { messages: [], channels: [], users: [], myUserId: null };
let REL_CONTACTS = []; // merged relationship contacts

// â”€â”€ Slack config â”€â”€
const SLACK_CLIENT_ID  = "729885942644.10595509625094";
const SLACK_REDIRECT   = window.location.origin + "/api/slack-callback";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MSAL SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const msalInstance = new msal.PublicClientApplication({
  auth: {
    clientId:    CLIENT_ID,
    authority:   `https://login.microsoftonline.com/${TENANT_ID}`,
    redirectUri: REDIRECT_URI
  },
  cache: { cacheLocation: "sessionStorage" }
});

const SCOPES = ["Mail.Read"];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showScreen(id) {
  ["login-screen", "loading-screen", "dashboard"].forEach(s => {
    const el = document.getElementById(s);
    if (s === id) {
      el.style.display = s === "dashboard" ? "block" : "flex";
    } else {
      el.style.display = "none";
    }
  });
}

function setLoading(text, progress = "", pct = null) {
  document.getElementById("loading-text").textContent = text;
  document.getElementById("loading-progress").textContent = progress;
  if (pct !== null) {
    document.getElementById("progress-bar").style.width = pct + "%";
  }
}

function showError(msg) {
  const el = document.getElementById("error-msg");
  el.textContent = msg;
  el.style.display = "block";
  document.getElementById("login-btn").disabled = false;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB NAVIGATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showTab(name) {
  document.querySelectorAll('.tab-section').forEach(s => s.classList.remove('active'));
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  const sec = document.getElementById('tab-' + name);
  if (sec) sec.classList.add('active');
  const btn = document.querySelector(`.tab-btn[data-tab="${name}"]`);
  if (btn) btn.classList.add('active');
}

function updateAuthBadges() {
  const eb = document.getElementById('badge-email');
  const sb = document.getElementById('badge-slack');
  if (eb) {
    if (AUTH_STATE.microsoft) { eb.style.display = ''; eb.className = 'tab-badge connected'; eb.textContent = 'âœ“'; }
    else { eb.style.display = 'none'; }
  }
  if (sb) {
    if (AUTH_STATE.slack) { sb.className = 'tab-badge connected'; sb.textContent = 'âœ“'; }
    else { sb.className = 'tab-badge not-connected'; sb.textContent = 'connect'; }
  }
}

function connectSlack() {
  const scopes = "channels:history,channels:read,groups:history,groups:read,im:history,im:read,mpim:history,mpim:read,reactions:read,users:read";
  const url = `https://slack.com/oauth/v2/authorize?client_id=${SLACK_CLIENT_ID}&user_scope=${scopes}&redirect_uri=${encodeURIComponent(SLACK_REDIRECT)}`;
  window.location.href = url;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUTH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function init() {
  // Check for Slack OAuth callback in hash
  handleSlackHash();

  await msalInstance.initialize();
  const accounts = msalInstance.getAllAccounts();
  if (accounts.length > 0) {
    msalInstance.setActiveAccount(accounts[0]);
    AUTH_STATE.microsoft = true;
    showScreen("loading-screen");
    setLoading("Loading your dataâ€¦", "", 5);
    await fetchAndRender();
  } else if (AUTH_STATE.slack) {
    // Only Slack connected â€” go to dashboard with Slack tab
    showScreen("dashboard");
    updateAuthBadges();
    showSlackCharts();
    showTab("slack");
    await fetchSlackAndRender();
  } else {
    showScreen("login-screen");
  }
}

function handleSlackHash() {
  const hash = window.location.hash.slice(1);
  if (!hash) return;
  const params = new URLSearchParams(hash);

  if (params.has("slack_token")) {
    SLACK_TOKEN = params.get("slack_token");
    SLACK_DATA.myUserId = params.get("slack_user_id") || null;
    AUTH_STATE.slack = true;
    // Store in sessionStorage for persistence during session
    sessionStorage.setItem("slack_token", SLACK_TOKEN);
    sessionStorage.setItem("slack_user_id", SLACK_DATA.myUserId || "");
    // Clean URL
    history.replaceState(null, "", window.location.pathname);
  } else if (params.has("slack_error")) {
    console.error("Slack OAuth error:", params.get("slack_error"));
    history.replaceState(null, "", window.location.pathname);
  }

  // Restore from session storage if available
  if (!SLACK_TOKEN) {
    const stored = sessionStorage.getItem("slack_token");
    if (stored) {
      SLACK_TOKEN = stored;
      SLACK_DATA.myUserId = sessionStorage.getItem("slack_user_id") || null;
      AUTH_STATE.slack = true;
    }
  }
}

function showSlackCharts() {
  const prompt = document.getElementById("slack-connect-prompt");
  const charts = document.getElementById("slack-charts");
  if (prompt) prompt.style.display = "none";
  if (charts) charts.style.display = "";
}

function showRelContent() {
  const prompt = document.getElementById("rel-connect-prompt");
  const content = document.getElementById("rel-content");
  if (prompt) prompt.style.display = "none";
  if (content) content.style.display = "";
}

async function login() {
  document.getElementById("login-btn").disabled = true;
  document.getElementById("error-msg").style.display = "none";
  try {
    const result = await msalInstance.loginPopup({ scopes: SCOPES });
    msalInstance.setActiveAccount(result.account);
    showScreen("loading-screen");
    setLoading("Connected! Fetching your inboxâ€¦", "", 5);
    await fetchAndRender();
  } catch (err) {
    showError("Sign-in failed: " + (err.message || err));
  }
}

async function signOut() {
  if (AUTH_STATE.microsoft) {
    try { await msalInstance.logoutPopup(); } catch(e) {}
  }
  AUTH_STATE = { microsoft: false, slack: false };
  SLACK_TOKEN = null;
  SLACK_DATA = { messages: [], channels: [], users: [], myUserId: null };
  ALL_RECEIVED = [];
  ALL_SENT = [];
  REL_CONTACTS = [];
  sessionStorage.removeItem("slack_token");
  sessionStorage.removeItem("slack_user_id");
  showScreen("login-screen");
}

async function getToken() {
  const account = msalInstance.getActiveAccount();
  const res = await msalInstance.acquireTokenSilent({ scopes: SCOPES, account });
  return res.accessToken;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GRAPH API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function fetchAllPages(firstUrl, onCount) {
  const all = [];
  let url = firstUrl;
  while (url) {
    const token = await getToken();
    const resp  = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
    if (!resp.ok) {
      const body = await resp.json().catch(() => ({}));
      throw new Error(body.error?.message || `HTTP ${resp.status}`);
    }
    const data = await resp.json();
    all.push(...(data.value || []));
    if (onCount) onCount(all.length);
    url = data["@odata.nextLink"] || null;
  }
  return all;
}

async function fetchAndRender() {
  const since = new Date();
  if (MONTHS_BACK === 0) {
    since.setHours(0, 0, 0, 0); // today from midnight
  } else {
    since.setMonth(since.getMonth() - MONTHS_BACK);
  }
  const sinceISO = since.toISOString();

  const recFields  = "id,receivedDateTime,from,toRecipients,ccRecipients,subject,conversationId,isRead,hasAttachments,bodyPreview";
  const sentFields = "id,sentDateTime,from,toRecipients,ccRecipients,subject,conversationId,hasAttachments,bodyPreview";

  const recUrl  = `${GRAPH}/me/mailFolders/inbox/messages?$select=${recFields}&$filter=${encodeURIComponent("receivedDateTime ge " + sinceISO)}&$top=100`;
  const sentUrl = `${GRAPH}/me/mailFolders/sentitems/messages?$select=${sentFields}&$filter=${encodeURIComponent("sentDateTime ge " + sinceISO)}&$top=100`;

  try {
    setLoading("Fetching received emailsâ€¦", "startingâ€¦", 10);
    ALL_RECEIVED = await fetchAllPages(recUrl, n => {
      setLoading("Fetching received emailsâ€¦", `${n} messages`, Math.min(10 + n / 25, 45));
    });

    setLoading("Fetching sent emailsâ€¦", "startingâ€¦", 50);
    ALL_SENT = await fetchAllPages(sentUrl, n => {
      setLoading("Fetching sent emailsâ€¦", `${n} messages`, Math.min(50 + n / 25, 85));
    });

    setLoading("Building dashboardâ€¦", "", 95);
    await new Promise(r => setTimeout(r, 300));

    const account = msalInstance.getActiveAccount();
    document.getElementById("account-badge").textContent = account?.username || "";
    AUTH_STATE.microsoft = true;
    updateAuthBadges();

    renderDashboard(ALL_RECEIVED, ALL_SENT);
    showScreen("dashboard");

    // If Slack is also connected, fetch Slack data in background
    if (AUTH_STATE.slack && SLACK_DATA.messages.length === 0) {
      showSlackCharts();
      fetchSlackAndRender();
    }

  } catch (err) {
    showScreen("login-screen");
    showError("Failed to load data: " + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SLACK DATA PIPELINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function slackAPI(method, params = {}) {
  const url = new URL(`https://slack.com/api/${method}`);
  Object.entries(params).forEach(([k, v]) => url.searchParams.set(k, v));
  let retries = 0;
  while (retries < 4) {
    const resp = await fetch(url.toString(), {
      headers: { Authorization: `Bearer ${SLACK_TOKEN}` }
    });
    if (resp.status === 429) {
      const wait = parseInt(resp.headers.get("Retry-After") || "5", 10);
      await new Promise(r => setTimeout(r, (wait + 1) * 1000));
      retries++;
      continue;
    }
    const data = await resp.json();
    if (!data.ok) throw new Error(`Slack API ${method}: ${data.error}`);
    return data;
  }
  throw new Error(`Slack API ${method}: rate limited after retries`);
}

async function fetchSlackUsers() {
  const data = await slackAPI("users.list");
  return (data.members || []).filter(u => !u.is_bot && !u.deleted && u.id !== "USLACKBOT");
}

async function fetchSlackConversations() {
  const all = [];
  let cursor = "";
  do {
    const params = { types: "public_channel,private_channel,mpim,im", limit: "200" };
    if (cursor) params.cursor = cursor;
    const data = await slackAPI("conversations.list", params);
    all.push(...(data.channels || []));
    cursor = data.response_metadata?.next_cursor || "";
  } while (cursor);
  return all;
}

async function fetchSlackHistory(channelId, oldest) {
  const all = [];
  let cursor = "";
  do {
    const params = { channel: channelId, limit: "200", oldest: String(oldest) };
    if (cursor) params.cursor = cursor;
    const data = await slackAPI("conversations.history", params);
    all.push(...(data.messages || []));
    cursor = data.response_metadata?.next_cursor || "";
  } while (cursor);
  return all;
}

async function fetchSlackAndRender() {
  try {
    setLoading("Fetching Slack usersâ€¦", "", 10);
    showScreen("loading-screen");
    const users = await fetchSlackUsers();
    const userMap = {};
    users.forEach(u => { userMap[u.id] = u.real_name || u.name; });
    SLACK_DATA.users = users;

    setLoading("Fetching Slack channelsâ€¦", "", 20);
    const convos = await fetchSlackConversations();
    SLACK_DATA.channels = convos;

    const cutoff = Math.floor(Date.now() / 1000) - (MONTHS_BACK || 12) * 30.44 * 86400;
    const messages = [];
    let done = 0;

    for (const ch of convos) {
      try {
        const msgs = await fetchSlackHistory(ch.id, cutoff);
        msgs.forEach(m => {
          messages.push({
            ts: parseFloat(m.ts),
            userId: m.user || m.bot_id || "",
            userName: userMap[m.user] || m.username || "bot",
            channelId: ch.id,
            channelName: ch.name || (ch.is_im ? `DM: ${userMap[ch.user] || ch.user}` : "group"),
            channelType: ch.is_im ? "dm" : ch.is_mpim ? "group" : ch.is_private ? "private" : "public",
            text: m.text || "",
            reactions: m.reactions || [],
            threadTs: m.thread_ts || null,
            replyCount: m.reply_count || 0,
            isReply: !!(m.thread_ts && m.thread_ts !== m.ts),
          });
        });
      } catch (e) {
        // Skip channels we can't access (not_in_channel etc)
        console.warn(`Skipping ${ch.name || ch.id}: ${e.message}`);
      }
      done++;
      setLoading("Fetching Slack messagesâ€¦", `${done}/${convos.length} channels`, 20 + (done / convos.length) * 60);
    }

    SLACK_DATA.messages = messages;
    setLoading("Building Slack chartsâ€¦", "", 90);
    await new Promise(r => setTimeout(r, 200));

    showScreen("dashboard");
    showSlackCharts();
    updateAuthBadges();
    renderSlackDashboard();

    // If both connected, build relationships
    if (AUTH_STATE.microsoft && ALL_RECEIVED.length > 0) {
      buildAndRenderRelationships();
    }
  } catch (err) {
    console.error("Slack fetch error:", err);
    showScreen("dashboard");
    // Show error in Slack tab
    const prompt = document.getElementById("slack-connect-prompt");
    if (prompt) {
      prompt.innerHTML = `<div class="connect-prompt-icon">âš ï¸</div><h2>Slack Error</h2><p>${err.message}</p><button class="btn-slack" onclick="connectSlack()"><svg viewBox="0 0 24 24" fill="currentColor" style="width:18px;height:18px"><path d="M5.042 15.165a2.528 2.528 0 0 1-2.52 2.523A2.528 2.528 0 0 1 0 15.165a2.527 2.527 0 0 1 2.522-2.52h2.52v2.52z"/></svg> Reconnect Slack</button>`;
      prompt.style.display = "";
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function weekKey(dateStr) {
  const d = new Date(dateStr);
  const day = d.getDay();
  const diff = d.getDate() - day + (day === 0 ? -6 : 1);
  const m = new Date(d);
  m.setDate(diff);
  m.setHours(0, 0, 0, 0);
  return m.toISOString().slice(0, 10);
}

function monthKey(dateStr) {
  const d = new Date(dateStr);
  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}`;
}

function groupByWeek(msgs, field) {
  const map = {};
  msgs.forEach(m => { const k = weekKey(m[field]); map[k] = (map[k] || 0) + 1; });
  return map;
}

function groupByDow(msgs, field) {
  const c = new Array(7).fill(0);
  msgs.forEach(m => c[new Date(m[field]).getDay()]++);
  return c;
}

function groupByHour(msgs, field) {
  const c = new Array(24).fill(0);
  msgs.forEach(m => c[new Date(m[field]).getHours()]++);
  return c;
}

function topN(msgs, keysFn, n = 10) {
  const map = {};
  msgs.forEach(m => {
    keysFn(m).forEach(k => { if (k) map[k] = (map[k] || 0) + 1; });
  });
  return Object.entries(map).sort((a, b) => b[1] - a[1]).slice(0, n);
}

function calcResponseTimes(received, sent) {
  const conv = {};
  received.forEach(m => {
    const id = m.conversationId;
    if (!conv[id]) conv[id] = [];
    conv[id].push(new Date(m.receivedDateTime).getTime());
  });

  const buckets = { "<1h": 0, "1â€“4h": 0, "4â€“24h": 0, "1â€“3d": 0, ">3d": 0 };

  sent.forEach(m => {
    const prev = conv[m.conversationId];
    if (!prev) return;
    const sentT = new Date(m.sentDateTime).getTime();
    const lastRec = prev.filter(t => t < sentT).sort((a, b) => b - a)[0];
    if (!lastRec) return;
    const hrs = (sentT - lastRec) / 3_600_000;
    if (hrs > 7 * 24) return;
    if      (hrs < 1)  buckets["<1h"]++;
    else if (hrs < 4)  buckets["1â€“4h"]++;
    else if (hrs < 24) buckets["4â€“24h"]++;
    else if (hrs < 72) buckets["1â€“3d"]++;
    else               buckets[">3d"]++;
  });

  return buckets;
}

function calcMonthlyReadRate(received) {
  const map = {};
  received.forEach(m => {
    const k = monthKey(m.receivedDateTime);
    if (!map[k]) map[k] = { total: 0, read: 0 };
    map[k].total++;
    if (m.isRead) map[k].read++;
  });
  return Object.entries(map)
    .sort((a, b) => a[0].localeCompare(b[0]))
    .map(([k, v]) => ({
      month: k,
      label: new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" }),
      rate:  v.total > 0 ? Math.round(v.read / v.total * 100) : 0
    }));
}

function calcMonthlyAttachments(received, sent) {
  const map = {};
  const add = (dateStr) => {
    const k = monthKey(dateStr);
    map[k] = (map[k] || 0) + 1;
  };
  received.filter(m => m.hasAttachments).forEach(m => add(m.receivedDateTime));
  sent.filter(m => m.hasAttachments).forEach(m => add(m.sentDateTime));
  const keys = Object.keys(map).sort();
  return {
    months: keys,
    labels: keys.map(k => new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" })),
    data:   keys.map(k => map[k])
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NORMALIZE: turn any message into a table row
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function normalizeMsg(m, type) {
  const dateField = type === "sent" ? "sentDateTime" : "receivedDateTime";
  const dateVal = m[dateField] || m.sentDateTime || m.receivedDateTime;
  return {
    date:       dateVal,
    from:       m.from?.emailAddress?.address || "(you)",
    to:         (m.toRecipients || []).map(r => r.emailAddress?.address).join(", ") || "â€”",
    subject:    m.subject || "(no subject)",
    attachment: m.hasAttachments ? "Yes" : "No",
    _type:      type
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRILL-DOWN MODAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let drillRows = [];
let drillSortCol = "date";
let drillSortAsc = false;

function openDrill(title, emails) {
  drillRows = emails;
  drillSortCol = "date";
  drillSortAsc = false;
  document.getElementById("drill-title").textContent = title;
  document.getElementById("drill-count").textContent = emails.length + " emails";
  renderDrillTable();
  document.getElementById("drill-overlay").classList.add("open");
  document.body.style.overflow = "hidden";
}

function closeDrill() {
  document.getElementById("drill-overlay").classList.remove("open");
  document.body.style.overflow = "";
}

function sortDrill(col) {
  if (drillSortCol === col) {
    drillSortAsc = !drillSortAsc;
  } else {
    drillSortCol = col;
    drillSortAsc = col === "date" ? false : true;
  }
  renderDrillTable();
}

function renderDrillTable() {
  ["date","from","to","subject","attachment"].forEach(c => {
    const el = document.getElementById("sort-" + c);
    if (c === drillSortCol) {
      el.textContent = drillSortAsc ? "â–²" : "â–¼";
    } else {
      el.textContent = "";
    }
  });

  const sorted = [...drillRows].sort((a, b) => {
    let va = a[drillSortCol], vb = b[drillSortCol];
    if (drillSortCol === "date") {
      va = new Date(va).getTime();
      vb = new Date(vb).getTime();
    } else {
      va = (va || "").toLowerCase();
      vb = (vb || "").toLowerCase();
    }
    if (va < vb) return drillSortAsc ? -1 : 1;
    if (va > vb) return drillSortAsc ? 1 : -1;
    return 0;
  });

  const tbody = document.getElementById("drill-tbody");
  tbody.innerHTML = sorted.map(r => {
    const d = new Date(r.date);
    const dateStr = d.toLocaleDateString("en", { month: "short", day: "numeric", year: "numeric" }) +
                    " " + d.toLocaleTimeString("en", { hour: "numeric", minute: "2-digit" });
    const attCls = r.attachment === "Yes" ? "att-yes" : "att-no";
    return `<tr>
      <td style="white-space:nowrap">${dateStr}</td>
      <td title="${r.from}">${r.from}</td>
      <td title="${r.to}">${r.to}</td>
      <td title="${r.subject}">${r.subject}</td>
      <td class="${attCls}">${r.attachment}</td>
    </tr>`;
  }).join("");
}

document.addEventListener("keydown", e => { if (e.key === "Escape") closeDrill(); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRILL-DOWN FILTER HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drillReceived(filterFn, title) {
  const emails = ALL_RECEIVED.filter(filterFn).map(m => normalizeMsg(m, "received"));
  openDrill(title, emails);
}

function drillSent(filterFn, title) {
  const emails = ALL_SENT.filter(filterFn).map(m => normalizeMsg(m, "sent"));
  openDrill(title, emails);
}

function drillBoth(recFilterFn, sentFilterFn, title) {
  const emails = [
    ...ALL_RECEIVED.filter(recFilterFn).map(m => normalizeMsg(m, "received")),
    ...ALL_SENT.filter(sentFilterFn).map(m => normalizeMsg(m, "sent"))
  ];
  openDrill(title, emails);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHART DEFAULTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const BASE_OPTS = {
  responsive: true,
  maintainAspectRatio: false,
  plugins: { legend: { display: false } },
  animation: { duration: 600 }
};

const GRID_COLOR  = "#f0f0f5";
const REC_COLOR   = "#5b6af9";
const SENT_COLOR  = "#f97066";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderDashboard(received, sent) {
  // Update overview label to reflect chosen range
  const lbl = document.getElementById("overview-label");
  if (lbl) {
    const m = MONTHS_BACK;
    if (m === 0)       lbl.textContent = "Today's overview";
    else if (m < 12)   lbl.textContent = `${m}-month overview`;
    else if (m % 12 === 0) lbl.textContent = `${m / 12}-year overview`;
    else               lbl.textContent = `${m}-month overview`;
  }
  renderStats(received, sent);
  renderTimeline(received, sent);
  renderDow(received, sent);
  renderHod(received, sent);
  renderTopSenders(received);
  renderTopRecipients(sent);
  renderResponseTimes(received, sent);
  renderReadRate(received);
  renderAttachments(received, sent);
  // â”€â”€ Engagement analytics â”€â”€
  renderEngagementScore(received, sent);
  renderTaskClassification(received, sent);
  renderTaskTrend(received, sent);
  renderThreadDepth(received, sent);
  renderParticipantDist(received, sent);
  renderEmailLength(received, sent);
  renderStakeholders(received, sent);
  renderResponseTrend(received, sent);
  renderTopSendersOverTime(received, sent);
  renderTopRecipientsOverTime(received, sent);
}

// â”€â”€ Stat cards (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderStats(received, sent) {
  const days = MONTHS_BACK > 0 ? MONTHS_BACK * 30.44 : 1;

  const dowCounts  = groupByDow(received, "receivedDateTime");
  const dowLabels  = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  const busyDowIdx = dowCounts.indexOf(Math.max(...dowCounts));
  const busyDow    = dowLabels[busyDowIdx];

  const hourCounts = groupByHour(received, "receivedDateTime");
  const busyHourN  = hourCounts.indexOf(Math.max(...hourCounts));
  const busyHour   = busyHourN === 0 ? "12am"
    : busyHourN < 12  ? `${busyHourN}am`
    : busyHourN === 12 ? "12pm"
    : `${busyHourN - 12}pm`;

  const recPerDay  = (received.length / days).toFixed(1);
  const sentPerDay = (sent.length / days).toFixed(1);

  const topSender  = topN(received, m => [m.from?.emailAddress?.address || ""], 1);
  const topSenderAddr = topSender[0]?.[0] || "";
  const topSenderDisplay = topSender[0]
    ? topSender[0][0].split("@")[0].replace(/[._]/g, " ")
    : "â€”";

  const attachPct  = received.length > 0
    ? Math.round(received.filter(m => m.hasAttachments).length / received.length * 100)
    : 0;

  const cards = [
    { label: "Received",         value: received.length.toLocaleString(), sub: `${recPerDay}/day avg`,  cls: "c-received",
      onclick: `drillReceived(() => true, 'All Received Emails')` },
    { label: "Sent",             value: sent.length.toLocaleString(),     sub: `${sentPerDay}/day avg`, cls: "c-sent",
      onclick: `drillSent(() => true, 'All Sent Emails')` },
    { label: "Busiest Day",      value: busyDow,    sub: "for incoming mail", cls: "",
      onclick: `drillReceived(m => new Date(m.receivedDateTime).getDay() === ${busyDowIdx}, 'Received on ${busyDow}s')` },
    { label: "Busiest Hour",     value: busyHour,   sub: "most mail arrives", cls: "",
      onclick: `drillReceived(m => new Date(m.receivedDateTime).getHours() === ${busyHourN}, 'Received at ${busyHour}')` },
    { label: "Top Sender",       value: topSenderDisplay, sub: topSenderAddr, cls: "",
      onclick: `drillReceived(m => m.from?.emailAddress?.address === '${topSenderAddr}', 'From ${topSenderAddr}')` },
    { label: "With Attachments", value: `${attachPct}%`, sub: "of received have files", cls: "",
      onclick: `drillReceived(m => m.hasAttachments, 'Received with Attachments')` },
  ];

  document.getElementById("stats-grid").innerHTML = cards.map(c => `
    <div class="stat-card ${c.cls}" onclick="${c.onclick}">
      <div class="stat-label">${c.label}</div>
      <div class="stat-value">${c.value}</div>
      <div class="stat-sub">${c.sub}</div>
    </div>
  `).join("");
}

// â”€â”€ Timeline (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTimeline(received, sent) {
  const recW  = groupByWeek(received, "receivedDateTime");
  const sentW = groupByWeek(sent, "sentDateTime");
  const keys  = [...new Set([...Object.keys(recW), ...Object.keys(sentW)])].sort();
  const labels = keys.map(k => {
    const d = new Date(k);
    return d.toLocaleDateString("en", { month: "short", day: "numeric" });
  });

  new Chart(document.getElementById("c-timeline"), {
    type: "line",
    data: {
      labels,
      datasets: [
        {
          label: "Received",
          data: keys.map(k => recW[k] || 0),
          borderColor: REC_COLOR,
          backgroundColor: REC_COLOR + "18",
          fill: true, tension: 0.4, pointRadius: 0, borderWidth: 2
        },
        {
          label: "Sent",
          data: keys.map(k => sentW[k] || 0),
          borderColor: SENT_COLOR,
          backgroundColor: SENT_COLOR + "18",
          fill: true, tension: 0.4, pointRadius: 0, borderWidth: 2
        }
      ]
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const wk = keys[idx];
        const label = labels[idx];
        drillBoth(
          m => weekKey(m.receivedDateTime) === wk,
          m => weekKey(m.sentDateTime) === wk,
          `Week of ${label}`
        );
      },
      plugins: {
        legend: { display: false },
        tooltip: { mode: "index", intersect: false }
      },
      scales: {
        x: { grid: { display: false }, ticks: { maxTicksLimit: 14, font: { size: 11 } } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true }
      }
    }
  });
}

// â”€â”€ Day of week (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderDow(received, sent) {
  const labels = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  new Chart(document.getElementById("c-dow"), {
    type: "bar",
    data: {
      labels,
      datasets: [
        { label: "Received", data: groupByDow(received, "receivedDateTime"), backgroundColor: REC_COLOR + "cc",  borderRadius: 5 },
        { label: "Sent",     data: groupByDow(sent, "sentDateTime"),          backgroundColor: SENT_COLOR + "cc", borderRadius: 5 }
      ]
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const dsIdx = elems[0].datasetIndex;
        const day = labels[idx];
        if (dsIdx === 0) {
          drillReceived(m => new Date(m.receivedDateTime).getDay() === idx, `Received on ${day}s`);
        } else {
          drillSent(m => new Date(m.sentDateTime).getDay() === idx, `Sent on ${day}s`);
        }
      },
      plugins: { legend: { display: true, labels: { boxWidth: 10, font: { size: 11 } } } },
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true }
      }
    }
  });
}

// â”€â”€ Hour of day (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderHod(received, sent) {
  const labels = Array.from({ length: 24 }, (_, i) =>
    i === 0 ? "12am" : i < 12 ? `${i}am` : i === 12 ? "12pm" : `${i-12}pm`
  );
  new Chart(document.getElementById("c-hod"), {
    type: "bar",
    data: {
      labels,
      datasets: [
        { label: "Received", data: groupByHour(received, "receivedDateTime"), backgroundColor: REC_COLOR + "cc",  borderRadius: 3 },
        { label: "Sent",     data: groupByHour(sent, "sentDateTime"),          backgroundColor: SENT_COLOR + "cc", borderRadius: 3 }
      ]
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const dsIdx = elems[0].datasetIndex;
        const hr = labels[idx];
        if (dsIdx === 0) {
          drillReceived(m => new Date(m.receivedDateTime).getHours() === idx, `Received at ${hr}`);
        } else {
          drillSent(m => new Date(m.sentDateTime).getHours() === idx, `Sent at ${hr}`);
        }
      },
      plugins: { legend: { display: true, labels: { boxWidth: 10, font: { size: 11 } } } },
      scales: {
        x: { grid: { display: false }, ticks: { maxTicksLimit: 8, font: { size: 11 } } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true }
      }
    }
  });
}

// â”€â”€ Top senders (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTopSenders(received) {
  const top = topN(received, m => [m.from?.emailAddress?.address || ""], 10);
  new Chart(document.getElementById("c-senders"), {
    type: "bar",
    data: {
      labels: top.map(([k]) => k.split("@")[0]),
      datasets: [{ data: top.map(([,v]) => v), backgroundColor: REC_COLOR + "cc", borderRadius: 4 }]
    },
    options: {
      ...BASE_OPTS,
      indexAxis: "y",
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const addr = top[idx][0];
        drillReceived(m => m.from?.emailAddress?.address === addr, `From ${addr}`);
      },
      scales: {
        x: { grid: { color: GRID_COLOR }, beginAtZero: true },
        y: { grid: { display: false }, ticks: { font: { size: 11 } } }
      }
    }
  });
}

// â”€â”€ Top recipients (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTopRecipients(sent) {
  const top = topN(sent, m => (m.toRecipients || []).map(r => r.emailAddress?.address || ""), 10);
  new Chart(document.getElementById("c-recipients"), {
    type: "bar",
    data: {
      labels: top.map(([k]) => k.split("@")[0]),
      datasets: [{ data: top.map(([,v]) => v), backgroundColor: SENT_COLOR + "cc", borderRadius: 4 }]
    },
    options: {
      ...BASE_OPTS,
      indexAxis: "y",
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const addr = top[idx][0];
        drillSent(m => (m.toRecipients || []).some(r => r.emailAddress?.address === addr), `To ${addr}`);
      },
      scales: {
        x: { grid: { color: GRID_COLOR }, beginAtZero: true },
        y: { grid: { display: false }, ticks: { font: { size: 11 } } }
      }
    }
  });
}

// â”€â”€ Response times (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderResponseTimes(received, sent) {
  const buckets = calcResponseTimes(received, sent);
  const colors  = ["#22c55e","#84cc16","#f59e0b","#f97066","#ef4444"];
  const bucketKeys = Object.keys(buckets);
  const thresholds = [[0,1],[1,4],[4,24],[24,72],[72,7*24]];

  const conv = {};
  received.forEach(m => {
    const id = m.conversationId;
    if (!conv[id]) conv[id] = [];
    conv[id].push(new Date(m.receivedDateTime).getTime());
  });

  new Chart(document.getElementById("c-response"), {
    type: "bar",
    data: {
      labels: bucketKeys,
      datasets: [{
        data: Object.values(buckets),
        backgroundColor: colors,
        borderRadius: 5
      }]
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const [lo, hi] = thresholds[idx];
        const label = bucketKeys[idx];
        const matchingSent = ALL_SENT.filter(m => {
          const prev = conv[m.conversationId];
          if (!prev) return false;
          const sentT = new Date(m.sentDateTime).getTime();
          const lastRec = prev.filter(t => t < sentT).sort((a, b) => b - a)[0];
          if (!lastRec) return false;
          const hrs = (sentT - lastRec) / 3_600_000;
          if (hrs > 7 * 24) return false;
          return hrs >= lo && hrs < hi;
        });
        openDrill(`Replies in ${label}`, matchingSent.map(m => normalizeMsg(m, "sent")));
      },
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â”€â”€ Read rate (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderReadRate(received) {
  const monthly = calcMonthlyReadRate(received);
  new Chart(document.getElementById("c-readrate"), {
    type: "bar",
    data: {
      labels: monthly.map(m => m.label),
      datasets: [{
        label: "Read %",
        data: monthly.map(m => m.rate),
        backgroundColor: monthly.map(m =>
          m.rate >= 80 ? "#22c55e99" : m.rate >= 50 ? "#f59e0b99" : "#f9706699"
        ),
        borderRadius: 4
      }]
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const mk = monthly[idx].month;
        const label = monthly[idx].label;
        drillReceived(m => monthKey(m.receivedDateTime) === mk, `Received in ${label}`);
      },
      scales: {
        x: { grid: { display: false }, ticks: { font: { size: 11 } } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, max: 100, ticks: { callback: v => v + "%" } }
      },
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: ctx => `${ctx.raw}% opened` } }
      }
    }
  });
}

// â”€â”€ Attachments (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderAttachments(received, sent) {
  const { months, labels, data } = calcMonthlyAttachments(received, sent);
  new Chart(document.getElementById("c-attachments"), {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "Emails with attachments",
        data,
        backgroundColor: "#a78bfa99",
        borderRadius: 5
      }]
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const mk = months[idx];
        const label = labels[idx];
        drillBoth(
          m => m.hasAttachments && monthKey(m.receivedDateTime) === mk,
          m => m.hasAttachments && monthKey(m.sentDateTime) === mk,
          `Emails with attachments in ${label}`
        );
      },
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TASK CLASSIFICATION â€” keyword scoring
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TASK_CATEGORIES = {
  "Sales":         ["sales","proposal","deal","client","prospect","pipeline","revenue","pricing","quote","offer","opportunity","customer","demo","pitch","crm","lead","account","contract renewal","upsell","cross-sell"],
  "Fundraising":   ["fundrais","investor","round","series a","series b","term sheet","cap table","vc","venture","valuation","due diligence","raise capital","investment","angel","spv","convertible","safe note"],
  "Hiring":        ["interview","candidate","hiring","recruit","offer letter","onboard","job","position","cv","resume","applicant","talent","headcount","role","hc "],
  "Finance":       ["invoice","payment","budget","expense","receipt","accounting","payroll","tax","reimburs","purchase order","p&l","cashflow","forecast","runway","burn"],
  "Legal":         ["contract","agreement","legal","compliance","nda","terms","gdpr","policy","liability","clause","ip ","trademark","copyright","litigation","dispute"],
  "1:1 / Sync":    ["1:1","one on one","one-on-one","catch up","catch-up","check-in","check in","weekly sync","standup","stand-up","bi-weekly","monthly review","feedback","skip"],
  "Internal":      ["all hands","all-hands","company update","announcement","team meeting","office","holiday","ooo","out of office","internal","company wide","company-wide"],
};

function classifySubject(subject) {
  const s = (subject || "").toLowerCase();
  // Score each category
  for (const [cat, keywords] of Object.entries(TASK_CATEGORIES)) {
    if (keywords.some(k => s.includes(k))) return cat;
  }
  return "Project / Other";
}

function calcTaskDistribution(received, sent) {
  const map = {};
  const allEmails = [
    ...received.map(m => ({ subject: m.subject, msg: m, type: "received" })),
    ...sent.map(m => ({ subject: m.subject, msg: m, type: "sent" }))
  ];
  allEmails.forEach(({ subject, msg, type }) => {
    const cat = classifySubject(subject);
    if (!map[cat]) map[cat] = { count: 0, received: [], sent: [] };
    map[cat].count++;
    map[cat][type].push(msg);
  });
  return map;
}

function calcMonthlyTaskTrend(received, sent) {
  // Returns { month -> { category -> count } }
  const months = {};
  const addMsg = (m, dateField) => {
    const mk = monthKey(m[dateField]);
    if (!months[mk]) months[mk] = {};
    const cat = classifySubject(m.subject);
    months[mk][cat] = (months[mk][cat] || 0) + 1;
  };
  received.forEach(m => addMsg(m, "receivedDateTime"));
  sent.forEach(m => addMsg(m, "sentDateTime"));
  return months;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THREAD ANALYTICS â€” group by conversationId
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildThreadMap(received, sent) {
  // Returns map of conversationId -> { messages[], participants Set, firstDate, lastDate }
  const threads = {};
  const addToThread = (m, dateField) => {
    const id = m.conversationId;
    if (!id) return;
    if (!threads[id]) threads[id] = { messages: [], participants: new Set(), firstDate: null, lastDate: null };
    threads[id].messages.push(m);
    const t = new Date(m[dateField]).getTime();
    if (!threads[id].firstDate || t < threads[id].firstDate) threads[id].firstDate = t;
    if (!threads[id].lastDate  || t > threads[id].lastDate)  threads[id].lastDate  = t;
    // collect participants
    const from = m.from?.emailAddress?.address;
    if (from) threads[id].participants.add(from);
    (m.toRecipients || []).forEach(r => { const a = r.emailAddress?.address; if (a) threads[id].participants.add(a); });
    (m.ccRecipients || []).forEach(r => { const a = r.emailAddress?.address; if (a) threads[id].participants.add(a); });
  };
  received.forEach(m => addToThread(m, "receivedDateTime"));
  sent.forEach(m => addToThread(m, "sentDateTime"));
  return threads;
}

function calcThreadStats(received, sent) {
  const threads = buildThreadMap(received, sent);
  const depths = Object.values(threads).map(t => t.messages.length);
  const participants = Object.values(threads).map(t => t.participants.size);
  const durations = Object.values(threads)
    .filter(t => t.firstDate && t.lastDate && t.lastDate > t.firstDate)
    .map(t => (t.lastDate - t.firstDate) / (1000 * 60 * 60 * 24)); // days

  const threadCount = depths.length;
  const avgDepth = threadCount ? (depths.reduce((a, b) => a + b, 0) / threadCount).toFixed(1) : 0;
  const avgParticipants = threadCount ? (participants.reduce((a, b) => a + b, 0) / threadCount).toFixed(1) : 0;

  // depth distribution buckets
  const depthBuckets = { "1 msg": 0, "2â€“3": 0, "4â€“7": 0, "8â€“15": 0, "16+": 0 };
  depths.forEach(d => {
    if      (d === 1)  depthBuckets["1 msg"]++;
    else if (d <= 3)   depthBuckets["2â€“3"]++;
    else if (d <= 7)   depthBuckets["4â€“7"]++;
    else if (d <= 15)  depthBuckets["8â€“15"]++;
    else               depthBuckets["16+"]++;
  });

  // participant distribution buckets
  const partBuckets = { "1:1": 0, "3â€“5": 0, "6â€“10": 0, "11â€“20": 0, "20+": 0 };
  participants.forEach(p => {
    if      (p <= 2)  partBuckets["1:1"]++;
    else if (p <= 5)  partBuckets["3â€“5"]++;
    else if (p <= 10) partBuckets["6â€“10"]++;
    else if (p <= 20) partBuckets["11â€“20"]++;
    else              partBuckets["20+"]++;
  });

  return { threadCount, avgDepth, avgParticipants, depthBuckets, partBuckets };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EMAIL LENGTH â€” word count from bodyPreview
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function estimateWordCount(bodyPreview) {
  if (!bodyPreview) return 0;
  return bodyPreview.trim().split(/\s+/).filter(w => w.length > 0).length;
}

function calcMonthlyEmailLength(received, sent) {
  // avg estimated word count per month, sent vs received
  const recMap = {}, sentMap = {};
  received.forEach(m => {
    const k = monthKey(m.receivedDateTime);
    if (!recMap[k]) recMap[k] = [];
    recMap[k].push(estimateWordCount(m.bodyPreview));
  });
  sent.forEach(m => {
    const k = monthKey(m.sentDateTime);
    if (!sentMap[k]) sentMap[k] = [];
    sentMap[k].push(estimateWordCount(m.bodyPreview));
  });
  const allKeys = [...new Set([...Object.keys(recMap), ...Object.keys(sentMap)])].sort();
  const avg = arr => arr.length ? Math.round(arr.reduce((a, b) => a + b, 0) / arr.length) : 0;
  return {
    labels: allKeys.map(k => new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" })),
    recAvg: allKeys.map(k => avg(recMap[k] || [])),
    sentAvg: allKeys.map(k => avg(sentMap[k] || []))
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STAKEHOLDER VARIETY â€” unique contacts per month
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calcMonthlyStakeholders(received, sent) {
  const map = {};
  received.forEach(m => {
    const k = monthKey(m.receivedDateTime);
    if (!map[k]) map[k] = new Set();
    const addr = m.from?.emailAddress?.address;
    if (addr) map[k].add(addr);
  });
  sent.forEach(m => {
    const k = monthKey(m.sentDateTime);
    if (!map[k]) map[k] = new Set();
    (m.toRecipients || []).forEach(r => { const a = r.emailAddress?.address; if (a) map[k].add(a); });
    (m.ccRecipients || []).forEach(r => { const a = r.emailAddress?.address; if (a) map[k].add(a); });
  });
  const keys = Object.keys(map).sort();
  return {
    labels: keys.map(k => new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" })),
    counts: keys.map(k => map[k].size)
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOP CONTACTS OVER TIME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calcTopContactsOverTime(received, sent, n = 5) {
  // For each month, who are top n senders and recipients?
  const recByMonth = {}, sentByMonth = {};
  received.forEach(m => {
    const k = monthKey(m.receivedDateTime);
    const addr = m.from?.emailAddress?.address;
    if (!addr) return;
    if (!recByMonth[k]) recByMonth[k] = {};
    recByMonth[k][addr] = (recByMonth[k][addr] || 0) + 1;
  });
  sent.forEach(m => {
    const k = monthKey(m.sentDateTime);
    (m.toRecipients || []).forEach(r => {
      const addr = r.emailAddress?.address;
      if (!addr) return;
      if (!sentByMonth[k]) sentByMonth[k] = {};
      sentByMonth[k][addr] = (sentByMonth[k][addr] || 0) + 1;
    });
  });
  const months = [...new Set([...Object.keys(recByMonth), ...Object.keys(sentByMonth)])].sort();

  // Build top-n senders per month as stacked data
  const topRecAddrs = Object.keys(
    received.reduce((acc, m) => {
      const a = m.from?.emailAddress?.address; if (a) acc[a] = (acc[a] || 0) + 1; return acc;
    }, {})
  ).sort((a, b) =>
    (received.filter(m => m.from?.emailAddress?.address === b).length) -
    (received.filter(m => m.from?.emailAddress?.address === a).length)
  ).slice(0, n);

  const topSentAddrs = Object.keys(
    sent.reduce((acc, m) => {
      (m.toRecipients || []).forEach(r => { const a = r.emailAddress?.address; if (a) acc[a] = (acc[a] || 0) + 1; }); return acc;
    }, {})
  ).sort((a, b) => {
    const bCount = sent.filter(m => (m.toRecipients||[]).some(r=>r.emailAddress?.address===b)).length;
    const aCount = sent.filter(m => (m.toRecipients||[]).some(r=>r.emailAddress?.address===a)).length;
    return bCount - aCount;
  }).slice(0, n);

  return {
    months,
    labels: months.map(k => new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" })),
    topRecAddrs,
    topSentAddrs,
    recByMonth,
    sentByMonth
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENGAGEMENT SCORE â€” monthly composite 0â€“100
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calcEngagementScore(received, sent) {
  // Per-month score from 4 signals:
  // 1. Reply rate (% of received convos that got a reply from you)
  // 2. Response speed (inverse of avg hours to reply, capped at 48h)
  // 3. Initiation rate (% of sent emails that start a NEW conversation)
  // 4. Network breadth (unique contacts contacted, normalised)

  const months = [...new Set([
    ...received.map(m => monthKey(m.receivedDateTime)),
    ...sent.map(m => monthKey(m.sentDateTime))
  ])].sort();

  // Build conversation lookup
  const convRecTimes = {}; // convId -> [timestamps of received]
  received.forEach(m => {
    const id = m.conversationId; if (!id) return;
    if (!convRecTimes[id]) convRecTimes[id] = [];
    convRecTimes[id].push(new Date(m.receivedDateTime).getTime());
  });

  const scores = months.map(mk => {
    const recMonth  = received.filter(m => monthKey(m.receivedDateTime) === mk);
    const sentMonth = sent.filter(m => monthKey(m.sentDateTime) === mk);
    if (recMonth.length + sentMonth.length < 5) return null; // not enough data

    // 1. Reply rate
    const recConvIds = new Set(recMonth.map(m => m.conversationId).filter(Boolean));
    const repliedConvIds = new Set(
      sentMonth.filter(m => recConvIds.has(m.conversationId)).map(m => m.conversationId)
    );
    const replyRate = recConvIds.size > 0 ? repliedConvIds.size / recConvIds.size : 0;

    // 2. Response speed: avg hours to reply (lower = better)
    const responseTimes = [];
    sentMonth.forEach(m => {
      const prev = convRecTimes[m.conversationId];
      if (!prev) return;
      const sentT = new Date(m.sentDateTime).getTime();
      const lastRec = prev.filter(t => t < sentT).sort((a, b) => b - a)[0];
      if (!lastRec) return;
      const hrs = (sentT - lastRec) / 3_600_000;
      if (hrs <= 48) responseTimes.push(hrs);
    });
    const avgHrs = responseTimes.length > 0
      ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length : 24;
    const speedScore = Math.max(0, 1 - (avgHrs / 48)); // 0h=1.0, 48h=0.0

    // 3. Initiation rate (sent emails whose conv has NO received message)
    const initiatedConvIds = sentMonth.filter(m =>
      m.conversationId && !convRecTimes[m.conversationId]
    ).length;
    const initiationRate = sentMonth.length > 0 ? initiatedConvIds / sentMonth.length : 0;

    // 4. Network breadth: unique contacts this month (normalised vs max across all months)
    const contacts = new Set();
    recMonth.forEach(m => { const a = m.from?.emailAddress?.address; if (a) contacts.add(a); });
    sentMonth.forEach(m => {
      (m.toRecipients||[]).forEach(r => { const a = r.emailAddress?.address; if (a) contacts.add(a); });
    });
    const breadth = contacts.size; // raw, normalised later

    // weighted composite (breadth normalised after collecting all months)
    return { mk, replyRate, speedScore, initiationRate, breadth, label:
      new Date(mk + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" }) };
  }).filter(Boolean);

  if (scores.length === 0) return [];

  const maxBreadth = Math.max(...scores.map(s => s.breadth), 1);
  return scores.map(s => {
    const breadthScore = s.breadth / maxBreadth;
    const composite = (
      s.replyRate     * 35 +
      s.speedScore    * 30 +
      s.initiationRate * 15 +
      breadthScore    * 20
    ); // already 0â€“100 scale
    return { mk: s.mk, label: s.label, score: Math.round(composite) };
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESPONSE TIME TREND â€” rolling monthly avg hours
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calcMonthlyResponseTrend(received, sent) {
  const convRecTimes = {};
  received.forEach(m => {
    const id = m.conversationId; if (!id) return;
    if (!convRecTimes[id]) convRecTimes[id] = [];
    convRecTimes[id].push(new Date(m.receivedDateTime).getTime());
  });

  const map = {};
  sent.forEach(m => {
    const prev = convRecTimes[m.conversationId];
    if (!prev) return;
    const sentT = new Date(m.sentDateTime).getTime();
    const lastRec = prev.filter(t => t < sentT).sort((a, b) => b - a)[0];
    if (!lastRec) return;
    const hrs = (sentT - lastRec) / 3_600_000;
    if (hrs > 7 * 24) return;
    const mk = monthKey(m.sentDateTime);
    if (!map[mk]) map[mk] = [];
    map[mk].push(hrs);
  });

  const keys = Object.keys(map).sort();
  const avg = arr => arr.length ? (arr.reduce((a, b) => a + b, 0) / arr.length).toFixed(1) : null;
  return {
    labels: keys.map(k => new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" })),
    avgHours: keys.map(k => avg(map[k]))
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW CHART RENDERERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Engagement Score over time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderEngagementScore(received, sent) {
  const scores = calcEngagementScore(received, sent);
  if (!scores.length) return;

  new Chart(document.getElementById("c-engagement"), {
    type: "line",
    data: {
      labels: scores.map(s => s.label),
      datasets: [{
        label: "Engagement Score",
        data: scores.map(s => s.score),
        borderColor: "#22c55e",
        backgroundColor: "rgba(34,197,94,0.1)",
        fill: true, tension: 0.4, pointRadius: 4,
        pointBackgroundColor: "#22c55e", borderWidth: 2
      }]
    },
    options: {
      ...BASE_OPTS,
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, max: 100,
             ticks: { callback: v => v } }
      },
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: ctx => `Score: ${ctx.raw}/100` } }
      }
    }
  });

  // Update stat card
  const latest = scores[scores.length - 1];
  const prev   = scores[scores.length - 2];
  const el = document.getElementById("engagement-stat");
  if (el && latest) {
    const trend = prev ? (latest.score > prev.score ? "â†‘" : latest.score < prev.score ? "â†“" : "â†’") : "";
    el.innerHTML = `<div class="stat-label">Engagement Score</div>
      <div class="stat-value" style="color:#22c55e">${latest.score}</div>
      <div class="stat-sub">${trend} vs last month Â· out of 100</div>`;
  }
}

// â”€â”€ Task classification donut â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TASK_COLORS = {
  "Sales":         "#6366f1",
  "Fundraising":   "#f59e0b",
  "Hiring":        "#06b6d4",
  "Finance":       "#84cc16",
  "Legal":         "#f97066",
  "1:1 / Sync":    "#a78bfa",
  "Internal":      "#94a3b8",
  "Project / Other": "#5b6af9"
};

function renderTaskClassification(received, sent) {
  const dist = calcTaskDistribution(received, sent);
  const entries = Object.entries(dist).sort((a, b) => b[1].count - a[1].count);

  new Chart(document.getElementById("c-tasks"), {
    type: "doughnut",
    data: {
      labels: entries.map(([k]) => k),
      datasets: [{
        data: entries.map(([,v]) => v.count),
        backgroundColor: entries.map(([k]) => TASK_COLORS[k] || "#94a3b8"),
        borderWidth: 2,
        borderColor: "#fff"
      }]
    },
    options: {
      ...BASE_OPTS,
      cutout: "62%",
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const cat = entries[elems[0].index][0];
        const data = dist[cat];
        openDrill(`Category: ${cat}`, [
          ...data.received.map(m => normalizeMsg(m, "received")),
          ...data.sent.map(m => normalizeMsg(m, "sent"))
        ]);
      },
      plugins: {
        legend: { display: true, position: "right",
          labels: { boxWidth: 11, font: { size: 11 }, padding: 10 } },
        tooltip: {
          callbacks: {
            label: ctx => {
              const total = entries.reduce((s, [,v]) => s + v.count, 0);
              const pct = total > 0 ? Math.round(ctx.raw / total * 100) : 0;
              return ` ${ctx.raw} emails (${pct}%)`;
            }
          }
        }
      }
    }
  });
}

// â”€â”€ Monthly task trend (stacked bar) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTaskTrend(received, sent) {
  const monthly = calcMonthlyTaskTrend(received, sent);
  const months = Object.keys(monthly).sort();
  const cats = Object.keys(TASK_COLORS);
  const labels = months.map(k => new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" }));

  new Chart(document.getElementById("c-task-trend"), {
    type: "bar",
    data: {
      labels,
      datasets: cats.map(cat => ({
        label: cat,
        data: months.map(mk => monthly[mk]?.[cat] || 0),
        backgroundColor: (TASK_COLORS[cat] || "#94a3b8") + "cc",
        borderRadius: 2
      }))
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const mi = elems[0].index;
        const di = elems[0].datasetIndex;
        const mk = months[mi];
        const cat = cats[di];
        const dist = calcTaskDistribution(
          received.filter(m => monthKey(m.receivedDateTime) === mk),
          sent.filter(m => monthKey(m.sentDateTime) === mk)
        );
        const data = dist[cat] || { received: [], sent: [] };
        openDrill(`${cat} â€” ${labels[mi]}`, [
          ...data.received.map(m => normalizeMsg(m, "received")),
          ...data.sent.map(m => normalizeMsg(m, "sent"))
        ]);
      },
      plugins: {
        legend: { display: true, labels: { boxWidth: 10, font: { size: 10 }, padding: 8 } }
      },
      scales: {
        x: { stacked: true, grid: { display: false }, ticks: { font: { size: 10 } } },
        y: { stacked: true, grid: { color: GRID_COLOR }, beginAtZero: true }
      }
    }
  });
}

// â”€â”€ Thread depth distribution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderThreadDepth(received, sent) {
  const { depthBuckets } = calcThreadStats(received, sent);
  const labels = Object.keys(depthBuckets);
  const colors = ["#e2e8f0","#a78bfa","#6366f1","#4f46e5","#312e81"];

  new Chart(document.getElementById("c-thread-depth"), {
    type: "bar",
    data: {
      labels,
      datasets: [{ data: Object.values(depthBuckets), backgroundColor: colors, borderRadius: 5 }]
    },
    options: {
      ...BASE_OPTS,
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â”€â”€ Participant count distribution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderParticipantDist(received, sent) {
  const { partBuckets } = calcThreadStats(received, sent);
  const labels = Object.keys(partBuckets);
  const colors = ["#bbf7d0","#6ee7b7","#34d399","#059669","#065f46"];

  new Chart(document.getElementById("c-participants"), {
    type: "bar",
    data: {
      labels,
      datasets: [{ data: Object.values(partBuckets), backgroundColor: colors, borderRadius: 5 }]
    },
    options: {
      ...BASE_OPTS,
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â”€â”€ Email length over time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderEmailLength(received, sent) {
  const { labels, recAvg, sentAvg } = calcMonthlyEmailLength(received, sent);
  new Chart(document.getElementById("c-email-length"), {
    type: "line",
    data: {
      labels,
      datasets: [
        { label: "Received (avg words)", data: recAvg, borderColor: REC_COLOR,
          backgroundColor: REC_COLOR + "15", fill: true, tension: 0.4, pointRadius: 3, borderWidth: 2 },
        { label: "Sent (avg words)", data: sentAvg, borderColor: SENT_COLOR,
          backgroundColor: SENT_COLOR + "15", fill: true, tension: 0.4, pointRadius: 3, borderWidth: 2 }
      ]
    },
    options: {
      ...BASE_OPTS,
      plugins: {
        legend: { display: true, labels: { boxWidth: 10, font: { size: 11 } } },
        tooltip: { callbacks: { label: ctx => `${ctx.dataset.label}: ~${ctx.raw} words` } }
      },
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true,
             ticks: { callback: v => v + "w" } }
      }
    }
  });
}

// â”€â”€ Unique stakeholders per month â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderStakeholders(received, sent) {
  const { labels, counts } = calcMonthlyStakeholders(received, sent);
  new Chart(document.getElementById("c-stakeholders"), {
    type: "line",
    data: {
      labels,
      datasets: [{
        label: "Unique contacts",
        data: counts,
        borderColor: "#06b6d4",
        backgroundColor: "rgba(6,182,212,0.1)",
        fill: true, tension: 0.4, pointRadius: 3, borderWidth: 2
      }]
    },
    options: {
      ...BASE_OPTS,
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: ctx => `${ctx.raw} unique contacts` } }
      },
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â”€â”€ Response time trend (monthly avg hours) â”€â”€â”€â”€â”€â”€
function renderResponseTrend(received, sent) {
  const { labels, avgHours } = calcMonthlyResponseTrend(received, sent);
  new Chart(document.getElementById("c-response-trend"), {
    type: "line",
    data: {
      labels,
      datasets: [{
        label: "Avg reply time (hrs)",
        data: avgHours,
        borderColor: "#f59e0b",
        backgroundColor: "rgba(245,158,11,0.1)",
        fill: true, tension: 0.4, pointRadius: 3, borderWidth: 2
      }]
    },
    options: {
      ...BASE_OPTS,
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: ctx => `${ctx.raw}h avg reply time` } }
      },
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true,
             ticks: { callback: v => v + "h" } }
      }
    }
  });
}

// â”€â”€ Top senders over time (line per contact) â”€â”€â”€â”€â”€
function renderTopSendersOverTime(received, sent) {
  const { months, labels, topRecAddrs, recByMonth } = calcTopContactsOverTime(received, sent, 5);
  const palette = ["#6366f1","#f97066","#22c55e","#f59e0b","#06b6d4"];

  new Chart(document.getElementById("c-senders-trend"), {
    type: "line",
    data: {
      labels,
      datasets: topRecAddrs.map((addr, i) => ({
        label: addr.split("@")[0],
        data: months.map(mk => recByMonth[mk]?.[addr] || 0),
        borderColor: palette[i % palette.length],
        backgroundColor: "transparent",
        tension: 0.4, pointRadius: 3, borderWidth: 2
      }))
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const addr = topRecAddrs[elems[0].datasetIndex];
        const mi = elems[0].index;
        const mk = months[mi];
        const label = labels[mi];
        drillReceived(
          m => m.from?.emailAddress?.address === addr && monthKey(m.receivedDateTime) === mk,
          `From ${addr} â€” ${label}`
        );
      },
      plugins: {
        legend: { display: true, labels: { boxWidth: 10, font: { size: 10 }, padding: 8 } }
      },
      scales: {
        x: { grid: { display: false }, ticks: { font: { size: 10 } } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â”€â”€ Top recipients over time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTopRecipientsOverTime(received, sent) {
  const { months, labels, topSentAddrs, sentByMonth } = calcTopContactsOverTime(received, sent, 5);
  const palette = ["#f97066","#6366f1","#f59e0b","#22c55e","#a78bfa"];

  new Chart(document.getElementById("c-recipients-trend"), {
    type: "line",
    data: {
      labels,
      datasets: topSentAddrs.map((addr, i) => ({
        label: addr.split("@")[0],
        data: months.map(mk => sentByMonth[mk]?.[addr] || 0),
        borderColor: palette[i % palette.length],
        backgroundColor: "transparent",
        tension: 0.4, pointRadius: 3, borderWidth: 2
      }))
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const addr = topSentAddrs[elems[0].datasetIndex];
        const mi = elems[0].index;
        const mk = months[mi];
        const label = labels[mi];
        drillSent(
          m => (m.toRecipients||[]).some(r => r.emailAddress?.address === addr) && monthKey(m.sentDateTime) === mk,
          `To ${addr} â€” ${label}`
        );
      },
      plugins: {
        legend: { display: true, labels: { boxWidth: 10, font: { size: 10 }, padding: 8 } }
      },
      scales: {
        x: { grid: { display: false }, ticks: { font: { size: 10 } } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SLACK RENDERERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const slackChartInstances = [];

function destroySlackCharts() {
  slackChartInstances.forEach(c => c.destroy());
  slackChartInstances.length = 0;
}

function slackChart(canvasId, config) {
  const c = new Chart(document.getElementById(canvasId), config);
  slackChartInstances.push(c);
  return c;
}

function renderSlackDashboard() {
  destroySlackCharts();
  const msgs = SLACK_DATA.messages;
  const myId = SLACK_DATA.myUserId;
  const sent = msgs.filter(m => m.userId === myId);
  const recv = msgs.filter(m => m.userId !== myId);

  renderSlackStats(msgs, sent, recv);
  renderSlackVolume(msgs, sent, recv);
  renderSlackChannels(msgs);
  renderSlackDMContacts(msgs, myId);
  renderSlackResponseTimes(msgs, myId);
  renderSlackReactions(msgs);
  renderSlackHeatmap(sent);
  renderSlackRatio(msgs);
  renderSlackLength(sent);
}

function renderSlackStats(msgs, sent, recv) {
  const days = (MONTHS_BACK || 12) * 30.44;
  const channels = new Set(msgs.map(m => m.channelId));
  const dmMsgs = msgs.filter(m => m.channelType === "dm");
  const uniqueDM = new Set(dmMsgs.map(m => m.userId));
  const cards = [
    { label: "Total Messages", value: msgs.length.toLocaleString(), sub: `${(msgs.length/days).toFixed(1)}/day` },
    { label: "Sent", value: sent.length.toLocaleString(), sub: `${(sent.length/days).toFixed(1)}/day` },
    { label: "Received", value: recv.length.toLocaleString(), sub: `${(recv.length/days).toFixed(1)}/day` },
    { label: "Active Channels", value: channels.size.toLocaleString(), sub: "channels & DMs" },
    { label: "DM Contacts", value: uniqueDM.size.toLocaleString(), sub: "people in DMs" },
    { label: "Reactions Given", value: msgs.reduce((a,m) => a + (m.reactions?.length || 0), 0).toLocaleString(), sub: "emoji reactions" },
  ];
  document.getElementById("slack-stats-grid").innerHTML = cards.map(c => `
    <div class="stat-card">
      <div class="stat-label">${c.label}</div>
      <div class="stat-value">${c.value}</div>
      <div class="stat-sub">${c.sub}</div>
    </div>
  `).join("");
}

function renderSlackVolume(msgs, sent, recv) {
  function groupByWeekSlack(arr) {
    const map = {};
    arr.forEach(m => {
      const d = new Date(m.ts * 1000);
      const day = d.getDay();
      const diff = d.getDate() - day + (day === 0 ? -6 : 1);
      const mon = new Date(d); mon.setDate(diff); mon.setHours(0,0,0,0);
      const k = mon.toISOString().slice(0,10);
      map[k] = (map[k] || 0) + 1;
    });
    return map;
  }
  const sentW = groupByWeekSlack(sent);
  const recvW = groupByWeekSlack(recv);
  const keys = [...new Set([...Object.keys(sentW), ...Object.keys(recvW)])].sort();
  const labels = keys.map(k => new Date(k).toLocaleDateString("en", { month: "short", day: "numeric" }));
  slackChart("c-slack-volume", {
    type: "line",
    data: {
      labels,
      datasets: [
        { label: "Received", data: keys.map(k => recvW[k]||0), borderColor: REC_COLOR, backgroundColor: REC_COLOR+"18", fill: true, tension: .4, pointRadius: 0, borderWidth: 2 },
        { label: "Sent", data: keys.map(k => sentW[k]||0), borderColor: SENT_COLOR, backgroundColor: SENT_COLOR+"18", fill: true, tension: .4, pointRadius: 0, borderWidth: 2 },
      ]
    },
    options: { ...BASE_OPTS, plugins: { legend: { display: false }, tooltip: { mode: "index", intersect: false } },
      scales: { x: { grid: { display: false }, ticks: { maxTicksLimit: 14, font: { size: 11 } } }, y: { grid: { color: GRID_COLOR }, beginAtZero: true } } }
  });
}

function renderSlackChannels(msgs) {
  const counts = {};
  msgs.forEach(m => { const n = m.channelName; counts[n] = (counts[n]||0)+1; });
  const sorted = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,10);
  const palette = ["#5b6af9","#f97066","#22c55e","#f59e0b","#8b5cf6","#ec4899","#06b6d4","#84cc16","#f43f5e","#6366f1"];
  slackChart("c-slack-channels", {
    type: "doughnut",
    data: {
      labels: sorted.map(s=>s[0]),
      datasets: [{ data: sorted.map(s=>s[1]), backgroundColor: palette.slice(0, sorted.length), borderWidth: 0 }]
    },
    options: { ...BASE_OPTS, cutout: "55%", plugins: { legend: { position: "right", labels: { boxWidth: 10, font: { size: 10 } } } } }
  });
}

function renderSlackDMContacts(msgs, myId) {
  const dms = msgs.filter(m => m.channelType === "dm" && m.userId !== myId);
  const counts = {};
  dms.forEach(m => { counts[m.userName] = (counts[m.userName]||0)+1; });
  const sorted = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,10);
  slackChart("c-slack-dm-contacts", {
    type: "bar",
    data: {
      labels: sorted.map(s=>s[0]),
      datasets: [{ data: sorted.map(s=>s[1]), backgroundColor: "#E01E5A", borderRadius: 5 }]
    },
    options: { ...BASE_OPTS, indexAxis: "y", plugins: { legend: { display: false } },
      scales: { x: { grid: { color: GRID_COLOR }, beginAtZero: true }, y: { grid: { display: false } } } }
  });
}

function renderSlackResponseTimes(msgs, myId) {
  // DM conversations: find pairs of messages
  const dmMsgs = msgs.filter(m => m.channelType === "dm").sort((a,b)=>a.ts-b.ts);
  const byChannel = {};
  dmMsgs.forEach(m => { (byChannel[m.channelId] = byChannel[m.channelId] || []).push(m); });

  const responseTimes = [];
  Object.values(byChannel).forEach(ch => {
    for (let i = 1; i < ch.length; i++) {
      if (ch[i].userId === myId && ch[i-1].userId !== myId) {
        const mins = (ch[i].ts - ch[i-1].ts) / 60;
        if (mins > 0 && mins < 1440) responseTimes.push(mins);
      }
    }
  });

  const buckets = ["<5m","5-15m","15-30m","30m-1h","1-2h","2-4h","4h+"];
  const thresholds = [5,15,30,60,120,240,Infinity];
  const counts = new Array(7).fill(0);
  responseTimes.forEach(t => {
    for (let i = 0; i < thresholds.length; i++) { if (t < thresholds[i]) { counts[i]++; break; } }
  });

  slackChart("c-slack-response", {
    type: "bar",
    data: { labels: buckets, datasets: [{ data: counts, backgroundColor: "#5b6af9cc", borderRadius: 5 }] },
    options: { ...BASE_OPTS, plugins: { legend: { display: false } },
      scales: { x: { grid: { display: false } }, y: { grid: { color: GRID_COLOR }, beginAtZero: true } } }
  });
}

function renderSlackReactions(msgs) {
  const counts = {};
  msgs.forEach(m => {
    (m.reactions || []).forEach(r => { counts[r.name] = (counts[r.name]||0) + (r.count || 1); });
  });
  const sorted = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,12);
  slackChart("c-slack-reactions", {
    type: "bar",
    data: {
      labels: sorted.map(s => `:${s[0]}:`),
      datasets: [{ data: sorted.map(s=>s[1]), backgroundColor: "#f59e0bcc", borderRadius: 4 }]
    },
    options: { ...BASE_OPTS, plugins: { legend: { display: false } },
      scales: { x: { grid: { display: false }, ticks: { font: { size: 10 } } }, y: { grid: { color: GRID_COLOR }, beginAtZero: true } } }
  });
}

function renderSlackHeatmap(sent) {
  // Day of week Ã— hour â€” rendered as a bubble chart
  const grid = Array.from({length:7}, () => new Array(24).fill(0));
  sent.forEach(m => {
    const d = new Date(m.ts * 1000);
    grid[d.getDay()][d.getHours()]++;
  });
  const dayLabels = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  const hourLabels = Array.from({length:24}, (_,i) => i===0?"12a":i<12?`${i}a`:i===12?"12p":`${i-12}p`);
  const data = [];
  const maxVal = Math.max(1, ...grid.flat());
  for (let d = 0; d < 7; d++) {
    for (let h = 0; h < 24; h++) {
      if (grid[d][h] > 0) {
        data.push({ x: h, y: d, r: Math.max(2, (grid[d][h] / maxVal) * 14), v: grid[d][h] });
      }
    }
  }
  slackChart("c-slack-heatmap", {
    type: "bubble",
    data: { datasets: [{ data, backgroundColor: "#5b6af966", borderColor: "#5b6af9", borderWidth: 1 }] },
    options: {
      ...BASE_OPTS,
      plugins: { legend: { display: false }, tooltip: {
        callbacks: { label: ctx => `${dayLabels[ctx.raw.y]} ${hourLabels[ctx.raw.x]}: ${ctx.raw.v} messages` }
      }},
      scales: {
        x: { type: "linear", min: -0.5, max: 23.5, ticks: { callback: v => hourLabels[v] || "", stepSize: 3, font: { size: 10 } }, grid: { display: false } },
        y: { type: "linear", min: -0.5, max: 6.5, ticks: { callback: v => dayLabels[v] || "", stepSize: 1, font: { size: 10 } }, grid: { color: GRID_COLOR }, reverse: false }
      }
    }
  });
}

function renderSlackRatio(msgs) {
  const types = { dm: 0, group: 0, public: 0, private: 0 };
  msgs.forEach(m => { types[m.channelType] = (types[m.channelType]||0)+1; });
  slackChart("c-slack-ratio", {
    type: "doughnut",
    data: {
      labels: ["DMs", "Group DMs", "Public Channels", "Private Channels"],
      datasets: [{ data: [types.dm, types.group, types.public, types.private],
        backgroundColor: ["#E01E5A","#ECB22E","#36C5F0","#2EB67D"], borderWidth: 0 }]
    },
    options: { ...BASE_OPTS, cutout: "55%", plugins: { legend: { position: "right", labels: { boxWidth: 10, font: { size: 11 } } } } }
  });
}

function renderSlackLength(sent) {
  const byMonth = {};
  sent.forEach(m => {
    const d = new Date(m.ts * 1000);
    const k = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}`;
    if (!byMonth[k]) byMonth[k] = [];
    byMonth[k].push((m.text || "").split(/\s+/).filter(Boolean).length);
  });
  const keys = Object.keys(byMonth).sort();
  const labels = keys.map(k => { const [y,m] = k.split("-"); return new Date(y, m-1).toLocaleDateString("en",{month:"short",year:"2-digit"}); });
  const data = keys.map(k => { const arr = byMonth[k]; return arr.length ? (arr.reduce((a,b)=>a+b,0)/arr.length).toFixed(1) : 0; });
  slackChart("c-slack-length", {
    type: "line",
    data: { labels, datasets: [{ label: "Avg words", data, borderColor: "#8b5cf6", backgroundColor: "#8b5cf618", fill: true, tension: .4, pointRadius: 3, borderWidth: 2 }] },
    options: { ...BASE_OPTS, plugins: { legend: { display: false } },
      scales: { x: { grid: { display: false } }, y: { grid: { color: GRID_COLOR }, beginAtZero: true } } }
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RELATIONSHIPS â€” CONTACT BRIDGE & RENDERERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const relChartInstances = [];
function destroyRelCharts() { relChartInstances.forEach(c=>c.destroy()); relChartInstances.length = 0; }
function relChart(id, cfg) { const c = new Chart(document.getElementById(id), cfg); relChartInstances.push(c); return c; }

function buildContactBridge() {
  // Build email contacts map
  const emailContacts = {};
  ALL_RECEIVED.forEach(m => {
    const addr = m.from?.emailAddress?.address?.toLowerCase();
    const name = m.from?.emailAddress?.name || "";
    if (addr) {
      if (!emailContacts[addr]) emailContacts[addr] = { name, address: addr, count: 0 };
      emailContacts[addr].count++;
    }
  });
  ALL_SENT.forEach(m => {
    (m.toRecipients || []).forEach(r => {
      const addr = r.emailAddress?.address?.toLowerCase();
      const name = r.emailAddress?.name || "";
      if (addr) {
        if (!emailContacts[addr]) emailContacts[addr] = { name, address: addr, count: 0 };
        emailContacts[addr].count++;
      }
    });
  });

  // Build Slack user map
  const slackUsers = {};
  SLACK_DATA.users.forEach(u => {
    const name = (u.real_name || u.name || "").toLowerCase().trim();
    slackUsers[u.id] = { name: u.real_name || u.name, nameLower: name, email: (u.profile?.email || "").toLowerCase(), id: u.id };
  });

  // Count Slack messages per user
  const slackCounts = {};
  SLACK_DATA.messages.forEach(m => {
    if (m.channelType === "dm") {
      slackCounts[m.userId] = (slackCounts[m.userId] || 0) + 1;
    }
  });

  // Match: email â†’ slack by (1) email match, (2) name match
  const contacts = [];
  const matchedSlackIds = new Set();

  Object.values(emailContacts).forEach(ec => {
    let slackMatch = null;

    // Try email match
    for (const su of Object.values(slackUsers)) {
      if (su.email && su.email === ec.address) { slackMatch = su; break; }
    }

    // Try name match
    if (!slackMatch) {
      const ecName = ec.name.toLowerCase().trim();
      const ecParts = ecName.split(/\s+/);
      for (const su of Object.values(slackUsers)) {
        if (matchedSlackIds.has(su.id)) continue;
        const suParts = su.nameLower.split(/\s+/);
        if (ecParts.length >= 2 && suParts.length >= 2 && ecParts[0] === suParts[0] && ecParts[ecParts.length-1] === suParts[suParts.length-1]) {
          slackMatch = su;
          break;
        }
      }
    }

    if (slackMatch) matchedSlackIds.add(slackMatch.id);

    contacts.push({
      name: ec.name || ec.address.split("@")[0],
      emailAddress: ec.address,
      slackUserId: slackMatch?.id || null,
      slackName: slackMatch?.name || null,
      emailCount: ec.count,
      slackCount: slackMatch ? (slackCounts[slackMatch.id] || 0) : 0,
      channels: slackMatch ? "both" : "email-only",
    });
  });

  // Add Slack-only contacts
  Object.values(slackUsers).forEach(su => {
    if (!matchedSlackIds.has(su.id) && (slackCounts[su.id] || 0) > 0) {
      contacts.push({
        name: su.name,
        emailAddress: null,
        slackUserId: su.id,
        slackName: su.name,
        emailCount: 0,
        slackCount: slackCounts[su.id] || 0,
        channels: "slack-only",
      });
    }
  });

  return contacts.sort((a,b) => (b.emailCount + b.slackCount) - (a.emailCount + a.slackCount));
}

function buildAndRenderRelationships() {
  REL_CONTACTS = buildContactBridge();
  showRelContent();
  destroyRelCharts();
  renderRelPreference();
  renderRelEngagement();
  renderRelCards();
}

function renderRelPreference() {
  const both = REL_CONTACTS.filter(c => c.channels === "both").length;
  const emailOnly = REL_CONTACTS.filter(c => c.channels === "email-only").length;
  const slackOnly = REL_CONTACTS.filter(c => c.channels === "slack-only").length;
  relChart("c-rel-preference", {
    type: "doughnut",
    data: {
      labels: ["Both channels", "Email only", "Slack only"],
      datasets: [{ data: [both, emailOnly, slackOnly], backgroundColor: ["#8b5cf6","#5b6af9","#E01E5A"], borderWidth: 0 }]
    },
    options: { ...BASE_OPTS, cutout: "55%", plugins: { legend: { position: "bottom", labels: { boxWidth: 10, font: { size: 11 } } } } }
  });
}

function renderRelEngagement() {
  // Top 15 contacts, stacked bar: email vs slack
  const top = REL_CONTACTS.slice(0, 15);
  relChart("c-rel-engagement", {
    type: "bar",
    data: {
      labels: top.map(c => c.name.split(" ")[0]),
      datasets: [
        { label: "Email", data: top.map(c => c.emailCount), backgroundColor: "#5b6af9cc", borderRadius: 3 },
        { label: "Slack", data: top.map(c => c.slackCount), backgroundColor: "#E01E5Acc", borderRadius: 3 }
      ]
    },
    options: { ...BASE_OPTS, indexAxis: "y", plugins: { legend: { display: true, labels: { boxWidth: 10, font: { size: 11 } } } },
      scales: { x: { stacked: true, grid: { color: GRID_COLOR }, beginAtZero: true }, y: { stacked: true, grid: { display: false } } } }
  });
}

function renderRelCards() {
  const sort = document.getElementById("rel-sort")?.value || "total";
  const filter = document.getElementById("rel-filter")?.value || "all";

  let filtered = [...REL_CONTACTS];
  if (filter === "both") filtered = filtered.filter(c => c.channels === "both");
  else if (filter === "email-only") filtered = filtered.filter(c => c.channels === "email-only");
  else if (filter === "slack-only") filtered = filtered.filter(c => c.channels === "slack-only");

  if (sort === "total") filtered.sort((a,b) => (b.emailCount+b.slackCount) - (a.emailCount+a.slackCount));
  else if (sort === "recent") filtered.sort((a,b) => (b.emailCount+b.slackCount) - (a.emailCount+a.slackCount)); // simplified
  else if (sort === "response") filtered.sort((a,b) => (b.emailCount+b.slackCount) - (a.emailCount+a.slackCount));

  const grid = document.getElementById("rel-cards-grid");
  if (!grid) return;

  grid.innerHTML = filtered.slice(0, 50).map(c => {
    const total = c.emailCount + c.slackCount;
    const emailPct = total > 0 ? Math.round(c.emailCount / total * 100) : 0;
    const slackPct = 100 - emailPct;
    const initials = c.name.split(" ").map(p => p[0]).join("").toUpperCase().slice(0,2);
    const channelLabel = c.channels === "both" ? "ğŸ“§ + ğŸ’¬" : c.channels === "email-only" ? "ğŸ“§ only" : "ğŸ’¬ only";
    return `
      <div class="rel-card">
        <div class="rel-card-header">
          <div class="rel-avatar">${initials}</div>
          <div>
            <div class="rel-name">${c.name}</div>
            <div class="rel-email">${c.emailAddress || c.slackName || ""} Â· ${channelLabel}</div>
          </div>
        </div>
        ${c.channels === "both" ? `
        <div class="rel-channel-bar">
          <div class="email-part" style="width:${emailPct}%"></div>
          <div class="slack-part" style="width:${slackPct}%"></div>
        </div>
        <div style="display:flex;justify-content:space-between;font-size:.68rem;color:var(--muted)">
          <span>ğŸ“§ ${emailPct}%</span><span>ğŸ’¬ ${slackPct}%</span>
        </div>` : ""}
        <div class="rel-stats">
          <div class="rel-stat"><div class="rel-stat-value">${total}</div><div class="rel-stat-label">Total</div></div>
          <div class="rel-stat"><div class="rel-stat-value">${c.emailCount}</div><div class="rel-stat-label">Emails</div></div>
          <div class="rel-stat"><div class="rel-stat-value">${c.slackCount}</div><div class="rel-stat-label">Slack</div></div>
        </div>
      </div>`;
  }).join("");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RADIAL TIME SLIDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SL = { cx: 120, cy: 120, r: 88 };
let sliderDragging = false;

function sliderFormat(m) {
  if (m === 0) return "Today";
  if (m < 12)  return `${m}mo`;
  const y  = Math.floor(m / 12);
  const mo = m % 12;
  if (mo === 0) return `${y}yr`;
  return `${y}yr ${mo}mo`;
}

function sliderArcPath(months) {
  if (months <= 0) return "";
  if (months >= 48) {
    // Full circle: two semicircles (SVG can't do a single-command full circle)
    return `M ${SL.cx} ${SL.cy - SL.r} A ${SL.r} ${SL.r} 0 0 1 ${SL.cx} ${SL.cy + SL.r} A ${SL.r} ${SL.r} 0 0 1 ${SL.cx} ${SL.cy - SL.r}`;
  }
  const startRad = -Math.PI / 2;                          // 12 o'clock
  const endRad   = startRad + (months / 48) * 2 * Math.PI; // clockwise
  const sx = SL.cx + SL.r * Math.cos(startRad);
  const sy = SL.cy + SL.r * Math.sin(startRad);
  const ex = SL.cx + SL.r * Math.cos(endRad);
  const ey = SL.cy + SL.r * Math.sin(endRad);
  const large = months > 24 ? 1 : 0;
  return `M ${sx.toFixed(3)} ${sy.toFixed(3)} A ${SL.r} ${SL.r} 0 ${large} 1 ${ex.toFixed(3)} ${ey.toFixed(3)}`;
}

function sliderHandlePos(months) {
  const rad = -Math.PI / 2 + (months / 48) * 2 * Math.PI;
  return {
    x: SL.cx + SL.r * Math.cos(rad),
    y: SL.cy + SL.r * Math.sin(rad)
  };
}

function updateSlider(months) {
  MONTHS_BACK = Math.max(0, Math.min(48, months));

  const arc    = document.getElementById("slider-arc");
  const handle = document.getElementById("slider-handle");
  const main   = document.getElementById("slider-main");
  const sub    = document.getElementById("slider-sub");

  arc.setAttribute("d", sliderArcPath(MONTHS_BACK));

  const hp = sliderHandlePos(MONTHS_BACK);
  handle.setAttribute("cx", hp.x.toFixed(3));
  handle.setAttribute("cy", hp.y.toFixed(3));

  main.textContent = sliderFormat(MONTHS_BACK);
  sub.textContent  = MONTHS_BACK === 0 ? "today only" : "of history";
}

function svgClientToMonths(svgEl, clientX, clientY) {
  const rect   = svgEl.getBoundingClientRect();
  const scaleX = 240 / rect.width;
  const scaleY = 240 / rect.height;
  const svgX   = (clientX - rect.left) * scaleX;
  const svgY   = (clientY - rect.top)  * scaleY;

  // atan2 from center, then normalize clockwise from 12 o'clock
  const angle    = Math.atan2(svgY - SL.cy, svgX - SL.cx) * 180 / Math.PI;
  const adjusted = ((angle + 90) + 360) % 360;
  return Math.round(adjusted / 360 * 48);
}

function initSlider() {
  const svg = document.getElementById("time-slider");

  // Mouse
  svg.addEventListener("mousedown", e => {
    sliderDragging = true;
    document.getElementById("slider-handle").classList.add("dragging");
    updateSlider(svgClientToMonths(svg, e.clientX, e.clientY));
    e.preventDefault();
  });
  document.addEventListener("mousemove", e => {
    if (!sliderDragging) return;
    updateSlider(svgClientToMonths(svg, e.clientX, e.clientY));
  });
  document.addEventListener("mouseup", () => {
    sliderDragging = false;
    const h = document.getElementById("slider-handle");
    if (h) h.classList.remove("dragging");
  });

  // Touch
  svg.addEventListener("touchstart", e => {
    sliderDragging = true;
    const t = e.touches[0];
    updateSlider(svgClientToMonths(svg, t.clientX, t.clientY));
    e.preventDefault();
  }, { passive: false });
  document.addEventListener("touchmove", e => {
    if (!sliderDragging) return;
    const t = e.touches[0];
    updateSlider(svgClientToMonths(svg, t.clientX, t.clientY));
    e.preventDefault();
  }, { passive: false });
  document.addEventListener("touchend", () => { sliderDragging = false; });

  // Set initial position
  updateSlider(18);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BOOT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
initSlider();
init();
</script>
</body>
</html>
