<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Email Dashboard</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/@azure/msal-browser@3.0.0/lib/msal-browser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
  /* â”€â”€ Design Tokens â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  :root {
    /* Glass system */
    --glass-opacity: 0.16;
    --glass-blur: 30px;
    --glass-radius: 24px;
    --glass-border: rgba(255,255,255,0.25);
    --glass-shadow: 0 20px 60px rgba(0,0,0,0.25);
    --glass-highlight: inset 0 1px 0 rgba(255,255,255,0.35);
    --glass-gradient: linear-gradient(to bottom, rgba(255,255,255,0.20), rgba(255,255,255,0.10));

    /* Text */
    --text-primary: rgba(255,255,255,0.9);
    --text-secondary: rgba(255,255,255,0.65);

    /* Motion */
    --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
    --duration-hover: 250ms;
    --duration-state: 350ms;

    /* Dashboard tokens (unchanged) */
    --bg:       #f0f2f9;
    --card:     #ffffff;
    --primary:  #5b6af9;
    --sent:     #f97066;
    --received: #5b6af9;
    --green:    #22c55e;
    --text-d:   #1e2035;
    --muted:    #6b7280;
    --border:   #e5e7eb;
    --radius:   14px;
    --shadow:   0 2px 16px rgba(0,0,0,0.06);
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text-d);
    min-height: 100vh;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     LEVEL 0 â€” Background Image (Depth-Blur)
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  #login-screen {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    position: relative;
    overflow: hidden;
    background: #1a2e0a;
  }

  /* Photographic background â€” heavy Gaussian blur removes all fine detail */
  #login-screen::before {
    content: '';
    position: absolute;
    inset: -10%;
    z-index: 0;
    background:
      /* Warm sun-ray spill, upper-left (ambient light source) */
      radial-gradient(ellipse 60% 55% at 28% 12%, rgba(235,218,160,0.70) 0%, rgba(190,200,120,0.30) 40%, transparent 68%),
      /* Secondary warm glow, upper-right */
      radial-gradient(ellipse 45% 40% at 72% 8%, rgba(210,195,140,0.45) 0%, transparent 60%),
      /* Bright rolling hill crest â€” mid-frame */
      radial-gradient(ellipse 100% 30% at 50% 48%, rgba(140,185,75,0.65) 0%, rgba(100,148,50,0.35) 50%, transparent 78%),
      /* Soft meadow light, center-left */
      radial-gradient(ellipse 35% 38% at 32% 42%, rgba(155,195,90,0.40) 0%, transparent 65%),
      /* Mid-ground tree mass, right */
      radial-gradient(ellipse 42% 55% at 78% 65%, rgba(22,52,14,0.85) 0%, rgba(38,72,22,0.45) 50%, transparent 75%),
      /* Dark canopy, top-left frame */
      radial-gradient(ellipse 50% 45% at 10% 5%, rgba(10,24,5,0.88) 0%, transparent 55%),
      /* Deep shadow, bottom */
      radial-gradient(ellipse 100% 40% at 50% 95%, rgba(8,18,4,0.75) 0%, transparent 70%),
      /* Base landscape gradient */
      linear-gradient(168deg, #0c1e04 0%, #1a3008 15%, #2c5212 32%, #3e7218 50%, #4a7c1c 65%, #365a10 80%, #142408 100%);
    filter: blur(60px) saturate(85%);
  }

  /* Tonal treatment: warm upper half + dark vignette bottom */
  #login-screen::after {
    content: '';
    position: absolute;
    inset: 0;
    z-index: 0;
    background:
      /* Subtle warmth top half */
      linear-gradient(180deg, rgba(200,180,120,0.08) 0%, transparent 50%),
      /* Dark vignette bottom */
      linear-gradient(0deg, rgba(0,0,0,0.32) 0%, transparent 45%),
      /* Corner vignette */
      radial-gradient(ellipse 80% 80% at 50% 50%, transparent 40%, rgba(0,0,0,0.22) 100%);
    pointer-events: none;
  }

  /* Animated orbs removed */
  .glass-orb { display: none; }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     LEVEL 1 â€” Primary Glass Container
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .login-card {
    background: rgba(255, 255, 255, var(--glass-opacity));
    backdrop-filter: blur(var(--glass-blur)) saturate(120%);
    -webkit-backdrop-filter: blur(var(--glass-blur)) saturate(120%);
    border: 1px solid var(--glass-border);
    border-radius: var(--glass-radius);
    padding: 48px 40px 32px;
    box-shadow: var(--glass-shadow);
    text-align: center;
    width: 400px;
    position: relative;
    z-index: 1;
    overflow: hidden;
  }

  /* Internal lighting gradient â€” top-left ambient source */
  .login-card::before {
    content: '';
    position: absolute;
    inset: 0;
    background: var(--glass-gradient);
    border-radius: var(--glass-radius);
    pointer-events: none;
  }

  /* Top-edge highlight (specular from ambient light) */
  .login-card::after {
    content: '';
    position: absolute;
    top: 0; left: 8%; right: 8%;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.35) 30%, rgba(255,255,255,0.35) 70%, transparent);
    pointer-events: none;
  }

  .login-icon { font-size: 2rem; margin-bottom: 16px; }

  .login-card h1 {
    font-size: 1.4rem;
    color: var(--text-primary);
    margin-bottom: 8px;
    letter-spacing: -0.02em;
    font-weight: 600;
  }

  .login-card p {
    color: var(--text-secondary);
    font-size: 0.85rem;
    margin-bottom: 32px;
    line-height: 1.6;
    font-weight: 400;
  }

  #error-msg {
    display: none;
    background: rgba(180, 30, 20, 0.14);
    backdrop-filter: blur(12px);
    color: rgba(255,180,170,0.9);
    border: 1px solid rgba(255, 200, 190, 0.15);
    border-radius: 12px;
    padding: 12px 16px;
    font-size: 0.82rem;
    margin-bottom: 16px;
    text-align: left;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     LEVEL 2 â€” Radial Time Slider (Raised Surface)
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .time-slider-section {
    margin: 0 0 32px;
    padding: 0;
    background: none;
    border: none;
    border-radius: 0;
  }

  .time-slider-label {
    font-size: 0.7rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-secondary);
    margin-bottom: 16px;
  }

  .time-slider-wrap {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #time-slider {
    cursor: pointer;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
    overflow: visible;
  }

  /* â”€â”€ Level 3: Slider Handle â€” Glass Bubble â”€â”€â”€â”€ */
  #slider-handle {
    transition: filter var(--duration-hover) var(--ease-out),
                transform var(--duration-hover) var(--ease-out);
    filter: drop-shadow(0 2px 8px rgba(0,0,0,0.35));
    cursor: grab;
  }
  #slider-handle:hover {
    filter: drop-shadow(0 0 12px rgba(255,255,255,0.35))
            drop-shadow(0 2px 8px rgba(0,0,0,0.30));
    transform: scale(1.02);
  }
  #slider-handle.dragging {
    cursor: grabbing;
    filter: drop-shadow(0 0 16px rgba(255,255,255,0.45))
            drop-shadow(0 2px 10px rgba(0,0,0,0.30));
    transform: scale(0.98);
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     LEVEL 2 â€” Sign-In Button (Raised Interactive)
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .btn-primary {
    background: rgba(255,255,255,0.14);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    color: var(--text-primary);
    border: 1px solid var(--glass-border);
    padding: 14px 28px;
    border-radius: 16px;
    font-size: 0.92rem;
    font-weight: 500;
    cursor: pointer;
    width: 100%;
    box-shadow:
      0 8px 32px rgba(0,0,0,0.18),
      var(--glass-highlight);
    transition: background var(--duration-hover) var(--ease-out),
                box-shadow var(--duration-hover) var(--ease-out),
                transform var(--duration-hover) var(--ease-out);
    letter-spacing: -0.005em;
    position: relative;
    overflow: hidden;
  }
  /* Internal light gradient on button */
  .btn-primary::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(to bottom, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
    border-radius: 16px;
    pointer-events: none;
  }
  .btn-primary:hover {
    background: rgba(255,255,255,0.20);
    box-shadow:
      0 12px 40px rgba(0,0,0,0.22),
      var(--glass-highlight);
    transform: translateY(-1px);
  }
  .btn-primary:active {
    transform: scale(0.98);
    box-shadow:
      0 4px 16px rgba(0,0,0,0.18),
      var(--glass-highlight);
  }
  .btn-primary:disabled { opacity: .4; cursor: default; transform: none; }

  /* â”€â”€ Loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #loading-screen {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    gap: 18px;
  }

  .spinner {
    width: 48px; height: 48px;
    border: 4px solid var(--border);
    border-top-color: var(--primary);
    border-radius: 50%;
    animation: spin .75s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  #loading-text     { font-weight: 600; }
  #loading-progress { font-size: .82rem; color: var(--muted); }

  .progress-bar-wrap {
    width: 260px; height: 4px;
    background: var(--border);
    border-radius: 99px;
    overflow: hidden;
  }
  .progress-bar-inner {
    height: 100%;
    background: var(--primary);
    border-radius: 99px;
    width: 0%;
    transition: width .3s;
  }

  /* â”€â”€ Dashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #dashboard { display: none; }

  header {
    background: var(--card);
    border-bottom: 1px solid var(--border);
    padding: 0 32px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: sticky; top: 0; z-index: 20;
  }

  .header-left { display: flex; align-items: center; gap: 10px; }
  .header-left h1 { font-size: 1rem; font-weight: 700; }
  #account-badge {
    font-size: .78rem;
    background: var(--bg);
    color: var(--muted);
    padding: 3px 10px;
    border-radius: 99px;
    border: 1px solid var(--border);
  }

  .btn-ghost {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--muted);
    padding: 6px 14px;
    border-radius: 8px;
    font-size: .82rem;
    cursor: pointer;
  }
  .btn-ghost:hover { background: var(--bg); }

  main {
    max-width: 1360px;
    margin: 0 auto;
    padding: 28px 32px 48px;
    display: flex;
    flex-direction: column;
    gap: 28px;
  }

  /* â”€â”€ Section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .section-label {
    font-size: .7rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .08em;
    color: var(--muted);
    margin-bottom: 14px;
  }

  /* â”€â”€ Stat cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(168px, 1fr));
    gap: 14px;
  }

  .stat-card {
    background: var(--card);
    border-radius: var(--radius);
    padding: 20px 22px;
    box-shadow: var(--shadow);
    display: flex;
    flex-direction: column;
    gap: 4px;
    cursor: pointer;
    transition: box-shadow .15s, transform .15s;
  }
  .stat-card:hover {
    box-shadow: 0 4px 24px rgba(0,0,0,0.12);
    transform: translateY(-1px);
  }

  .stat-label { font-size: .78rem; color: var(--muted); }
  .stat-value { font-size: 2rem; font-weight: 800; line-height: 1.1; }
  .stat-sub   { font-size: .73rem; color: var(--muted); margin-top: 2px; }

  .stat-card.c-received .stat-value { color: var(--received); }
  .stat-card.c-sent     .stat-value { color: var(--sent); }

  /* â”€â”€ Chart cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .charts-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 18px;
  }

  .chart-card {
    background: var(--card);
    border-radius: var(--radius);
    padding: 24px 26px;
    box-shadow: var(--shadow);
  }

  .chart-card.full { grid-column: 1 / -1; }

  .chart-title    { font-size: .93rem; font-weight: 700; margin-bottom: 2px; }
  .chart-subtitle { font-size: .78rem; color: var(--muted); margin-bottom: 20px; }

  .chart-wrap { position: relative; cursor: pointer; }

  .legend {
    display: flex; gap: 18px;
    margin-top: 14px;
    font-size: .78rem; color: var(--muted);
  }
  .legend-item { display: flex; align-items: center; gap: 6px; }
  .legend-dot  { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; }

  /* â”€â”€ Drill-down modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #drill-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.45);
    z-index: 100;
    align-items: flex-start;
    justify-content: center;
    padding: 40px 20px;
    overflow-y: auto;
  }
  #drill-overlay.open { display: flex; }

  .drill-panel {
    background: var(--card);
    border-radius: 16px;
    width: 100%;
    max-width: 960px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.18);
    overflow: hidden;
    animation: slideUp .25s ease-out;
  }
  @keyframes slideUp {
    from { opacity: 0; transform: translateY(20px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  .drill-header {
    padding: 20px 24px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .drill-header h2 { font-size: 1rem; font-weight: 700; }
  .drill-count {
    font-size: .8rem;
    color: var(--muted);
    background: var(--bg);
    padding: 3px 10px;
    border-radius: 99px;
    margin-left: 10px;
  }
  .drill-close {
    background: none;
    border: 1px solid var(--border);
    border-radius: 8px;
    width: 32px; height: 32px;
    font-size: 1.1rem;
    cursor: pointer;
    color: var(--muted);
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .drill-close:hover { background: var(--bg); }

  .drill-body {
    max-height: 65vh;
    overflow-y: auto;
  }

  .drill-table {
    width: 100%;
    border-collapse: collapse;
    font-size: .82rem;
  }
  .drill-table thead { position: sticky; top: 0; background: var(--card); z-index: 2; }
  .drill-table th {
    text-align: left;
    padding: 10px 14px;
    font-weight: 600;
    font-size: .72rem;
    text-transform: uppercase;
    letter-spacing: .05em;
    color: var(--muted);
    border-bottom: 2px solid var(--border);
    cursor: pointer;
    user-select: none;
    white-space: nowrap;
  }
  .drill-table th:hover { color: var(--text-d); }
  .drill-table th .sort-arrow { margin-left: 4px; font-size: .65rem; }
  .drill-table td {
    padding: 9px 14px;
    border-bottom: 1px solid #f3f4f6;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .drill-table tbody tr:hover { background: #f8f9ff; }
  .drill-table .att-yes { color: var(--primary); font-weight: 600; }
  .drill-table .att-no  { color: #d1d5db; }

  /* â”€â”€ Demo button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .demo-divider {
    display: flex;
    align-items: center;
    gap: 12px;
    margin: 18px 0 14px;
    color: rgba(255,255,255,0.30);
    font-size: .75rem;
  }
  .demo-divider::before,
  .demo-divider::after {
    content: "";
    flex: 1;
    height: 1px;
    background: rgba(255,255,255,0.12);
  }

  .btn-demo {
    width: 100%;
    padding: 12px 20px;
    background: rgba(255,255,255,0.06);
    border: 1px dashed rgba(255,255,255,0.22);
    border-radius: 14px;
    color: rgba(255,255,255,0.55);
    font-size: .85rem;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    letter-spacing: .01em;
    transition: background 200ms ease, color 200ms ease, border-color 200ms ease;
  }
  .btn-demo:hover {
    background: rgba(255,255,255,0.12);
    color: rgba(255,255,255,0.80);
    border-color: rgba(255,255,255,0.35);
  }
  .btn-demo:active { transform: scale(0.98); }
  .btn-demo-icon { font-size: .9rem; opacity: .7; }

  /* â”€â”€ Section dividers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .section-divider {
    display: flex;
    align-items: center;
    gap: 14px;
    margin: 10px 0 4px;
  }
  .section-divider::before,
  .section-divider::after {
    content: "";
    flex: 1;
    height: 1px;
    background: var(--border);
  }
  .section-label-inline {
    font-size: .72rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: .1em;
    color: var(--muted);
    white-space: nowrap;
    padding: 0 4px;
  }

  /* â”€â”€ Engagement banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .engagement-stat-banner {
    display: flex;
    gap: 14px;
    flex-wrap: wrap;
    margin-bottom: 18px;
  }
  .eng-pill {
    background: var(--bg);
    border-radius: 12px;
    padding: 10px 18px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    min-width: 80px;
  }
  .eng-pill-value {
    font-size: 1.5rem;
    font-weight: 800;
    line-height: 1.1;
    color: var(--primary);
  }
  .eng-pill-label {
    font-size: .7rem;
    color: var(--muted);
    text-align: center;
  }

  /* â”€â”€ Asymmetric 2-column grid (1/3 + 2/3) â”€â”€ */
  .charts-grid-2-3 {
    grid-template-columns: 1fr 2fr;
  }

  @media (max-width: 800px) {
    main { padding: 16px; }
    .charts-grid { grid-template-columns: 1fr; }
    .charts-grid-2-3 { grid-template-columns: 1fr; }
    .chart-card.full { grid-column: 1; }
    .drill-panel { max-width: 100%; }
    .login-card { width: 92vw; padding: 36px 24px 28px; }
  }
</style>
</head>
<body>

<!-- â”€â”€ LOGIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="login-screen">
  <div class="glass-orb glass-orb-1"></div>
  <div class="glass-orb glass-orb-2"></div>
  <div class="glass-orb glass-orb-3"></div>

  <div class="login-card">
    <div class="login-icon">ğŸ“§</div>
    <h1>Email Dashboard</h1>
    <p>Sign in with your Microsoft work account to analyse your email patterns.</p>

    <!-- â”€â”€ Radial time slider â”€â”€ -->
    <div class="time-slider-section">
      <div class="time-slider-label">Time range</div>
      <div class="time-slider-wrap">
        <svg id="time-slider" viewBox="0 0 240 240" width="204" height="204">
          <defs>
            <!-- Arc gradient: semi-transparent white, slightly more opaque than track -->
            <linearGradient id="arcGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%"   stop-color="rgba(255,255,255,0.60)"/>
              <stop offset="100%" stop-color="rgba(255,255,255,0.35)"/>
            </linearGradient>
            <!-- Handle: glass bubble with top-left specular highlight -->
            <radialGradient id="handleGrad" cx="35%" cy="30%" r="65%">
              <stop offset="0%"   stop-color="rgba(255,255,255,0.95)"/>
              <stop offset="60%"  stop-color="rgba(255,255,255,0.55)"/>
              <stop offset="100%" stop-color="rgba(255,255,255,0.30)"/>
            </radialGradient>
            <!-- Handle border (subtle glass edge) -->
            <radialGradient id="handleBorderGrad" cx="35%" cy="30%" r="65%">
              <stop offset="0%"   stop-color="rgba(255,255,255,0.60)"/>
              <stop offset="100%" stop-color="rgba(255,255,255,0.20)"/>
            </radialGradient>
            <!-- Soft glow on active arc -->
            <filter id="arcGlow" x="-20%" y="-20%" width="140%" height="140%">
              <feGaussianBlur in="SourceGraphic" stdDeviation="2.5" result="blur"/>
              <feMerge>
                <feMergeNode in="blur"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>

          <!-- Track ring â€” semi-transparent white -->
          <circle cx="120" cy="120" r="88"
            fill="none"
            stroke="rgba(255,255,255,0.08)"
            stroke-width="12"/>

          <!-- Subtle year markers â€” no heavy ticks, just soft labels -->
          <text x="222" y="124" fill="rgba(255,255,255,0.25)" font-size="9" font-weight="400"
            text-anchor="middle" font-family="Inter,-apple-system,BlinkMacSystemFont,sans-serif">1y</text>
          <text x="120" y="224" fill="rgba(255,255,255,0.25)" font-size="9" font-weight="400"
            text-anchor="middle" font-family="Inter,-apple-system,BlinkMacSystemFont,sans-serif">2y</text>
          <text x="18"  y="124" fill="rgba(255,255,255,0.25)" font-size="9" font-weight="400"
            text-anchor="middle" font-family="Inter,-apple-system,BlinkMacSystemFont,sans-serif">3y</text>
          <text x="120" y="17"  fill="rgba(255,255,255,0.25)" font-size="9" font-weight="400"
            text-anchor="middle" font-family="Inter,-apple-system,BlinkMacSystemFont,sans-serif">4y</text>

          <!-- Active progress arc -->
          <path id="slider-arc"
            fill="none"
            stroke="url(#arcGrad)"
            stroke-width="12"
            stroke-linecap="round"
            filter="url(#arcGlow)"/>

          <!-- Center: large spacious value -->
          <text id="slider-main" x="120" y="112"
            text-anchor="middle" dominant-baseline="middle"
            fill="var(--text-primary)"
            font-size="30" font-weight="500"
            font-family="Inter, -apple-system, BlinkMacSystemFont, sans-serif"
            letter-spacing="-0.03em">18mo</text>

          <!-- Center: secondary label -->
          <text id="slider-sub" x="120" y="138"
            text-anchor="middle" dominant-baseline="middle"
            fill="var(--text-secondary)"
            font-size="10.5" font-weight="400"
            font-family="Inter, -apple-system, BlinkMacSystemFont, sans-serif">of history</text>

          <!-- Handle: glass bubble â€” same blur+border rule as container -->
          <circle id="slider-handle" r="12"
            fill="url(#handleGrad)"
            stroke="url(#handleBorderGrad)"
            stroke-width="1.5"/>
        </svg>
      </div>
    </div>

    <div id="error-msg"></div>
    <button class="btn-primary" id="login-btn" onclick="login()">Sign in with Microsoft</button>

    <div class="demo-divider"><span>or</span></div>
    <button class="btn-demo" onclick="loadDemoData()">
      <span class="btn-demo-icon">âœ¦</span> Try with demo data
    </button>
  </div>
</div>

<!-- â”€â”€ LOADING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="loading-screen">
  <div class="spinner"></div>
  <div id="loading-text">Connectingâ€¦</div>
  <div class="progress-bar-wrap"><div class="progress-bar-inner" id="progress-bar"></div></div>
  <div id="loading-progress"></div>
</div>

<!-- â”€â”€ DASHBOARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="dashboard">

  <header>
    <div class="header-left">
      <span style="font-size:1.4rem">ğŸ“§</span>
      <h1>Email Dashboard</h1>
      <span id="account-badge"></span>
    </div>
    <button class="btn-ghost" onclick="signOut()">Sign out</button>
  </header>

  <main>
    <!-- Stats -->
    <div>
      <div class="section-label" id="overview-label">Overview</div>
      <div class="stats-grid" id="stats-grid"></div>
    </div>

    <!-- Timeline -->
    <div class="chart-card full">
      <div class="chart-title">Email Volume Over Time</div>
      <div class="chart-subtitle">Weekly totals â€” sent vs received Â· click a point to drill in</div>
      <div class="chart-wrap" style="height:240px"><canvas id="c-timeline"></canvas></div>
      <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:var(--received)"></div>Received</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--sent)"></div>Sent</div>
      </div>
    </div>

    <!-- Day of week + Hour of day -->
    <div class="charts-grid">
      <div class="chart-card">
        <div class="chart-title">Day of Week</div>
        <div class="chart-subtitle">Activity by weekday Â· click to drill in</div>
        <div class="chart-wrap" style="height:210px"><canvas id="c-dow"></canvas></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Hour of Day</div>
        <div class="chart-subtitle">When your inbox is most active Â· click to drill in</div>
        <div class="chart-wrap" style="height:210px"><canvas id="c-hod"></canvas></div>
      </div>
    </div>

    <!-- Top senders + recipients -->
    <div class="charts-grid">
      <div class="chart-card">
        <div class="chart-title">Top Senders</div>
        <div class="chart-subtitle">Who emails you most Â· click a bar to see emails</div>
        <div class="chart-wrap" style="height:280px"><canvas id="c-senders"></canvas></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Top Recipients</div>
        <div class="chart-subtitle">Who you email most Â· click a bar to see emails</div>
        <div class="chart-wrap" style="height:280px"><canvas id="c-recipients"></canvas></div>
      </div>
    </div>

    <!-- Response time + Read rate -->
    <div class="charts-grid">
      <div class="chart-card">
        <div class="chart-title">Response Times</div>
        <div class="chart-subtitle">How quickly you reply Â· click a bucket to see emails</div>
        <div class="chart-wrap" style="height:210px"><canvas id="c-response"></canvas></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Monthly Read Rate</div>
        <div class="chart-subtitle">% of received emails you opened Â· click to drill in</div>
        <div class="chart-wrap" style="height:210px"><canvas id="c-readrate"></canvas></div>
      </div>
    </div>

    <!-- Attachment rate -->
    <div class="chart-card full">
      <div class="chart-title">Emails with Attachments</div>
      <div class="chart-subtitle">Monthly count of messages with file attachments Â· click to drill in</div>
      <div class="chart-wrap" style="height:200px"><canvas id="c-attachments"></canvas></div>
    </div>

    <!-- â”€â”€ ENGAGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div class="section-divider">
      <span class="section-label-inline">Engagement Analytics</span>
    </div>

    <!-- Engagement score stat + chart -->
    <div class="chart-card full">
      <div class="chart-title">Engagement Score Over Time</div>
      <div class="chart-subtitle">Composite monthly score: reply rate Â· response speed Â· email initiation Â· network breadth</div>
      <div id="engagement-stat" class="engagement-stat-banner"></div>
      <div class="chart-wrap" style="height:220px"><canvas id="c-engagement"></canvas></div>
    </div>

    <!-- Task classification: doughnut + trend -->
    <div class="charts-grid charts-grid-2-3">
      <div class="chart-card">
        <div class="chart-title">Task Classification</div>
        <div class="chart-subtitle">Subject-line keyword categories Â· click a segment</div>
        <div class="chart-wrap" style="height:260px"><canvas id="c-tasks"></canvas></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Category Trend Over Time</div>
        <div class="chart-subtitle">Monthly stacked breakdown Â· click a column</div>
        <div class="chart-wrap" style="height:260px"><canvas id="c-task-trend"></canvas></div>
      </div>
    </div>

    <!-- â”€â”€ THREAD ANALYTICS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div class="section-divider">
      <span class="section-label-inline">Thread Analytics</span>
    </div>

    <div class="charts-grid">
      <div class="chart-card">
        <div class="chart-title">Thread Depth Distribution</div>
        <div class="chart-subtitle">How many messages per conversation</div>
        <div class="chart-wrap" style="height:220px"><canvas id="c-thread-depth"></canvas></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Participants per Thread</div>
        <div class="chart-subtitle">Group size distribution across conversations</div>
        <div class="chart-wrap" style="height:220px"><canvas id="c-participants"></canvas></div>
      </div>
    </div>

    <!-- â”€â”€ TRENDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div class="section-divider">
      <span class="section-label-inline">Volume &amp; Trend</span>
    </div>

    <div class="charts-grid">
      <div class="chart-card">
        <div class="chart-title">Average Email Length</div>
        <div class="chart-subtitle">Estimated word count per message (sent vs received)</div>
        <div class="chart-wrap" style="height:210px"><canvas id="c-email-length"></canvas></div>
        <div class="legend">
          <div class="legend-item"><div class="legend-dot" style="background:var(--received)"></div>Received</div>
          <div class="legend-item"><div class="legend-dot" style="background:var(--sent)"></div>Sent</div>
        </div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Unique Stakeholders per Month</div>
        <div class="chart-subtitle">Distinct people in your inbox each month</div>
        <div class="chart-wrap" style="height:210px"><canvas id="c-stakeholders"></canvas></div>
      </div>
    </div>

    <div class="chart-card full">
      <div class="chart-title">Monthly Average Response Time</div>
      <div class="chart-subtitle">How quickly you replied to emails each month (hours)</div>
      <div class="chart-wrap" style="height:200px"><canvas id="c-response-trend"></canvas></div>
    </div>

    <!-- â”€â”€ CONTACT TRENDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div class="section-divider">
      <span class="section-label-inline">Contact Trends</span>
    </div>

    <div class="chart-card full">
      <div class="chart-title">Top Senders Over Time</div>
      <div class="chart-subtitle">Monthly email volume from your most frequent senders Â· click a name to drill in</div>
      <div class="chart-wrap" style="height:240px"><canvas id="c-senders-trend"></canvas></div>
    </div>

    <div class="chart-card full">
      <div class="chart-title">Top Recipients Over Time</div>
      <div class="chart-subtitle">Monthly email volume to your most frequent recipients Â· click a name to drill in</div>
      <div class="chart-wrap" style="height:240px"><canvas id="c-recipients-trend"></canvas></div>
    </div>

  </main>
</div><!-- /dashboard -->

<!-- â”€â”€ DRILL-DOWN MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="drill-overlay" onclick="if(event.target===this)closeDrill()">
  <div class="drill-panel">
    <div class="drill-header">
      <div style="display:flex;align-items:center">
        <h2 id="drill-title">Emails</h2>
        <span class="drill-count" id="drill-count"></span>
      </div>
      <button class="drill-close" onclick="closeDrill()">âœ•</button>
    </div>
    <div class="drill-body">
      <table class="drill-table">
        <thead>
          <tr>
            <th onclick="sortDrill('date')">Date <span class="sort-arrow" id="sort-date">â–¼</span></th>
            <th onclick="sortDrill('from')">From <span class="sort-arrow" id="sort-from"></span></th>
            <th onclick="sortDrill('to')">To <span class="sort-arrow" id="sort-to"></span></th>
            <th onclick="sortDrill('subject')">Subject <span class="sort-arrow" id="sort-subject"></span></th>
            <th onclick="sortDrill('attachment')">Attachment <span class="sort-arrow" id="sort-attachment"></span></th>
          </tr>
        </thead>
        <tbody id="drill-tbody"></tbody>
      </table>
    </div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEMO DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function generateDemoData() {
  const ME_EMAIL = "csongor@cambri.io";
  const ME_NAME  = "Csongor";

  // Deterministic seeded RNG for reproducible charts
  let seed = 7919;
  const rng  = () => { seed = (seed * 1664525 + 1013904223) >>> 0; return seed / 0x100000000; };
  const pick = arr => arr[Math.floor(rng() * arr.length)];
  const rInt = (lo, hi) => lo + Math.floor(rng() * (hi - lo + 1));
  const rBool = (p = 0.5) => rng() < p;

  const C = [
    // Inner circle
    { name:"Sarah Chen",       email:"sarah.chen@acmecorp.io",        freq:1.00 },
    { name:"Marcus Webb",      email:"marcus@nexuspartners.com",       freq:0.88 },
    { name:"Priya Sharma",     email:"p.sharma@acmecorp.io",          freq:0.80 },
    { name:"James O'Brien",    email:"james@bridgevc.com",            freq:0.72 },
    { name:"Lena Fischer",     email:"l.fischer@acmecorp.io",         freq:0.65 },
    // Regular
    { name:"Tom Bradley",      email:"t.bradley@stellartech.io",      freq:0.48 },
    { name:"Aisha Osei",       email:"a.osei@globalstrategy.com",     freq:0.42 },
    { name:"David Park",       email:"d.park@acmecorp.io",            freq:0.38 },
    { name:"Emma Thornton",    email:"e.thornton@counsellors.co",     freq:0.36 },
    { name:"Rafael Santos",    email:"r.santos@launchbase.io",        freq:0.30 },
    { name:"Yuki Tanaka",      email:"y.tanaka@globalstrategy.com",   freq:0.26 },
    { name:"Hannah Mueller",   email:"h.mueller@nexuspartners.com",   freq:0.24 },
    // Occasional
    { name:"Ben Foster",       email:"ben@fostervc.com",              freq:0.14 },
    { name:"Clara Diaz",       email:"c.diaz@launchbase.io",          freq:0.12 },
    { name:"Oliver Wright",    email:"o.wright@acmecorp.io",          freq:0.10 },
    { name:"Nadia Ali",        email:"nadia@globalstrategy.com",      freq:0.10 },
    { name:"Chris Barton",     email:"c.barton@stellartech.io",       freq:0.08 },
    { name:"Fatima Hassan",    email:"f.hassan@counsellors.co",       freq:0.08 },
    { name:"Luke Peterson",    email:"l.peterson@nexuspartners.com",  freq:0.07 },
    { name:"Anna Kowalski",    email:"a.kowalski@acmecorp.io",        freq:0.07 },
    { name:"Sam Torres",       email:"s.torres@launchbase.io",        freq:0.06 },
    { name:"Mei Lin",          email:"mei.lin@globalstrategy.com",    freq:0.06 },
    { name:"Jack Harrison",    email:"j.harrison@fostervc.com",       freq:0.05 },
    { name:"Bea Dupont",       email:"b.dupont@counsellors.co",       freq:0.05 },
    { name:"Arjun Mehta",      email:"a.mehta@bridgevc.com",          freq:0.04 },
  ];

  const SUBJ = {
    "Sales":          ["Proposal â€” {co} Q{q}","Follow-up: {name} <> {co}","{co} deal status","Intro: {name} from {co}","Pricing update â€” {co}","Pipeline review Q{q}","{co} contract renewal","Customer success: {co}"],
    "Fundraising":    ["Series A â€” investor update","Intro: {name} ({vc})","Cap table model","{vc} term sheet review","Monthly investor update","Due diligence checklist","Lead investor: {name}","Fund close â€” final steps"],
    "Hiring":         ["Interview: {name} â€” {role}","Offer letter â€” {name}","Hiring pipeline update","Candidate feedback: {name}","Reference check â€” {name}","New role: {role}","{name} â€” start date","Recruiter brief: {role}"],
    "Finance":        ["Invoice #{n} â€” {mo}","Q{q} budget review","Expense report â€” {mo}","Monthly P&L â€” {mo}","Payment #{n} confirmed","{mo} payroll","FY{yr} projections","A/P queue update"],
    "Legal":          ["NDA â€” {co}","Contract review â€” {co}","IP assignment â€” {name}","T&Cs update","Employment agreement â€” {name}","SHA revision","Compliance update â€” {mo}","DPA â€” {co}"],
    "1:1 / Sync":     ["1:1 agenda â€” {name}","Weekly sync with {name}","Catch-up re: {topic}","Quick chat?","Our call tomorrow","{topic} â€” let's align","Coffee â€” {name}","Monthly 1:1 â€” {name}"],
    "Internal":       ["All-hands recap â€” {mo}","Company update â€” {mo}","Team announcement","Q{q} OKR review","Culture survey results","Office hours â€” {mo}","{dept} offsite","Internal newsletter"],
    "Project / Other":["Project {proj}: status","Sprint {n} planning","{proj} launch prep","Feature request: {feature}","Bug triage â€” {proj}","{proj} roadmap Q{q}","Milestone reached","User research findings"],
  };

  const CAT_W = [
    ["Internal",0.27],["Sales",0.20],["1:1 / Sync",0.14],["Project / Other",0.14],
    ["Finance",0.09],["Hiring",0.08],["Legal",0.05],["Fundraising",0.03],
  ];
  function pickCat() {
    let r = rng(), cum = 0;
    for (const [cat,w] of CAT_W) { cum += w; if (r < cum) return cat; }
    return "Project / Other";
  }

  const FILL = {
    cos:     ["Acme Corp","TechVentures","GlobalTech","LaunchBase","Stellar IO","Nexus","BridgeCo"],
    vcs:     ["Sequoia","a16z","Accel","Index","Northzone","Tiger","Benchmark"],
    roles:   ["Head of Sales","Sr Engineer","Marketing Lead","Product Manager","Data Analyst","CTO","CFO"],
    projs:   ["Phoenix","Atlas","Nebula","Apex","Horizon","Forge","Nova"],
    features:["dark mode","SSO","export API","notifications","bulk upload","webhooks"],
    topics:  ["roadmap","Q3 targets","budget","team structure","launch timeline","strategy"],
    depts:   ["Engineering","Marketing","Sales","Finance","Product","Design"],
    months:  ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
  };

  function mkSubject(cat) {
    const tpl = pick(SUBJ[cat]);
    const now  = new Date();
    return tpl
      .replace("{name}",    pick(C).name.split(" ")[0])
      .replace("{co}",      pick(FILL.cos))
      .replace("{vc}",      pick(FILL.vcs))
      .replace("{role}",    pick(FILL.roles))
      .replace("{proj}",    pick(FILL.projs))
      .replace("{feature}", pick(FILL.features))
      .replace("{topic}",   pick(FILL.topics))
      .replace("{dept}",    pick(FILL.depts))
      .replace("{mo}",      FILL.months[now.getMonth()])
      .replace("{yr}",      String(now.getFullYear()).slice(-2))
      .replace("{q}",       String(Math.ceil((now.getMonth()+1)/3)))
      .replace("{n}",       String(rInt(100,999)));
  }

  const PREVIEWS = [
    "Following up on our conversation from last week. I wanted to share the updated documents and get your thoughts before we proceed with the next steps.",
    "Quick note â€” I've reviewed the materials and have a few questions. Can we find 30 minutes to connect this week? I think it's worth aligning before we move forward.",
    "Thanks for the intro! I've had a chance to look through the details and I think there's a strong fit here. Happy to discuss further at your convenience.",
    "Just wanted to confirm we're still on for tomorrow's call. Let me know if anything changes on your end and we can reschedule if needed.",
    "I've attached the revised version based on your feedback. Please let me know if this looks good or if you'd like any further changes before we finalize.",
    "Great news â€” the team has signed off on this. I'll coordinate next steps on our end and keep you in the loop as things progress over the coming days.",
    "Circling back on this thread. I know we've all been busy but wanted to make sure this doesn't fall through the cracks given the timeline we discussed.",
    "Please find attached the document you requested. Let me know if you need anything else from my side or if there are outstanding questions I can address.",
    "Quick update: we've made progress on this since we last spoke. I'll share more context in our next sync but wanted to flag the movement now.",
    "Thanks for your patience on this. I've been working through the details carefully and wanted to give you a proper answer rather than something rushed.",
    "Wanted to loop you in on this thread as it's become directly relevant to the work we discussed. Feel free to jump in with any thoughts or questions.",
    "This is looking solid overall. A few minor items to resolve but nothing blocking progress. Let's aim to finalize by end of week if possible.",
    "Following up on the open items from our last meeting. I've made progress on most of them â€” see my notes below for the full picture.",
    "Just a heads up that there's been a slight delay on this end. Nothing major, wanted to keep you informed so there are no surprises down the line.",
    "I've shared this with the relevant stakeholders on our side and we're aligned. Currently waiting on final sign-off from the finance team before proceeding.",
    "Really appreciate you moving quickly on this. Looking forward to getting started and making meaningful progress together on this initiative.",
    "A few things I'd like to discuss before we finalize. I'll prepare a brief agenda and send it over the day before so we can make the most of our time.",
    "This got a bit more complex than initially expected, but I think we have a solid path forward now. Let me walk you through my thinking when we connect.",
    "Good timing on this â€” we were just discussing something very similar internally. There may be a real opportunity here worth exploring together.",
    "Everything looks good from our side. Just need your signature on the attached and we're ready to move forward and kick things off officially.",
  ];

  const received = [], sent = [];
  let msgId = 1, convId = 1;
  const now = new Date();

  // Month busyness index (0=Jan â€¦ 11=Dec)
  const BUSY = [1.15,1.10,1.08,0.95,0.90,0.82,0.72,0.80,0.97,1.12,1.22,0.68];

  for (let m = 0; m < 12; m++) {
    const mDate  = new Date(now.getFullYear(), now.getMonth() - 11 + m, 1);
    const daysInM = new Date(mDate.getFullYear(), mDate.getMonth() + 1, 0).getDate();
    const busy   = BUSY[mDate.getMonth()];

    for (const ct of C) {
      const count = Math.max(0, Math.round(ct.freq * 14 * busy) + rInt(-1, 1));
      for (let i = 0; i < count; i++) {
        let day = rInt(1, daysInM);
        const dow = new Date(mDate.getFullYear(), mDate.getMonth(), day).getDay();
        if ((dow === 0 || dow === 6) && rBool(0.72)) continue; // skip most weekends
        const hour = rBool(0.72) ? rInt(8,18) : rInt(6,22);
        const ts   = new Date(mDate.getFullYear(), mDate.getMonth(), day, hour, rInt(0,59), 0);
        if (ts > now) continue;

        const cat  = pickCat();
        const subj = mkSubject(cat);
        const cId  = "conv_" + convId;
        const ccList = rBool(0.18) ? [{ emailAddress: { name: pick(C.filter(x=>x!==ct)).name, address: pick(C.filter(x=>x!==ct)).email } }] : [];

        received.push({
          id: "r"+msgId++, receivedDateTime: ts.toISOString(),
          from: { emailAddress: { name: ct.name, address: ct.email } },
          toRecipients: [{ emailAddress: { name: ME_NAME, address: ME_EMAIL } }],
          ccRecipients: ccList, subject: subj, conversationId: cId,
          isRead: rBool(0.84), hasAttachments: rBool(0.17), bodyPreview: pick(PREVIEWS),
        });

        // Reply (builds thread + response-time data)
        if (rBool(0.46)) {
          const delayMin = rInt(15, 48*60);
          const rTs = new Date(ts.getTime() + delayMin*60000);
          if (rTs <= now) {
            sent.push({
              id: "s"+msgId++, sentDateTime: rTs.toISOString(),
              from: { emailAddress: { name: ME_NAME, address: ME_EMAIL } },
              toRecipients: [{ emailAddress: { name: ct.name, address: ct.email } }],
              ccRecipients: ccList, subject: "Re: "+subj, conversationId: cId,
              hasAttachments: rBool(0.08), bodyPreview: pick(PREVIEWS),
            });
            // Their follow-up reply
            if (rBool(0.28)) {
              const r2Ts = new Date(rTs.getTime() + rInt(30,6*60)*60000);
              if (r2Ts <= now) {
                received.push({
                  id: "r"+msgId++, receivedDateTime: r2Ts.toISOString(),
                  from: { emailAddress: { name: ct.name, address: ct.email } },
                  toRecipients: [{ emailAddress: { name: ME_NAME, address: ME_EMAIL } }],
                  ccRecipients: ccList, subject: "Re: "+subj, conversationId: cId,
                  isRead: rBool(0.88), hasAttachments: rBool(0.10), bodyPreview: pick(PREVIEWS),
                });
              }
            }
          }
        }

        // Proactive sent emails (not replies)
        if (rBool(0.14)) {
          const sDay = rInt(1, daysInM);
          const sTs  = new Date(mDate.getFullYear(), mDate.getMonth(), sDay, rBool(0.75)?rInt(8,18):rInt(6,22), rInt(0,59), 0);
          if (sTs <= now) {
            sent.push({
              id: "s"+msgId++, sentDateTime: sTs.toISOString(),
              from: { emailAddress: { name: ME_NAME, address: ME_EMAIL } },
              toRecipients: [{ emailAddress: { name: ct.name, address: ct.email } }],
              ccRecipients: [], subject: mkSubject(cat),
              conversationId: "conv_"+(convId+5000),
              hasAttachments: rBool(0.12), bodyPreview: pick(PREVIEWS),
            });
          }
        }

        convId++;
      }
    }
  }

  return { received, sent };
}

function loadDemoData() {
  MONTHS_BACK = 12;
  const { received, sent } = generateDemoData();
  ALL_RECEIVED = received;
  ALL_SENT     = sent;
  document.getElementById("account-badge").textContent = "Demo Mode";
  const lbl = document.getElementById("overview-label");
  if (lbl) lbl.textContent = "12-month overview";
  showScreen("dashboard");
  renderDashboard(ALL_RECEIVED, ALL_SENT);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CLIENT_ID    = "52975658-2cda-4237-a140-6f4f60b5f67c";
const TENANT_ID    = "d0a04723-fdc3-4b9f-b4ca-ed07f918688a";
const REDIRECT_URI = window.location.origin;
const GRAPH        = "https://graph.microsoft.com/v1.0";

// Driven by the radial slider (default 18)
let MONTHS_BACK = 18;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL DATA STORE (populated after fetch)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let ALL_RECEIVED = [];
let ALL_SENT     = [];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MSAL SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const msalInstance = new msal.PublicClientApplication({
  auth: {
    clientId:    CLIENT_ID,
    authority:   `https://login.microsoftonline.com/${TENANT_ID}`,
    redirectUri: REDIRECT_URI
  },
  cache: { cacheLocation: "sessionStorage" }
});

const SCOPES = ["Mail.Read"];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showScreen(id) {
  ["login-screen", "loading-screen", "dashboard"].forEach(s => {
    const el = document.getElementById(s);
    if (s === id) {
      el.style.display = s === "dashboard" ? "block" : "flex";
    } else {
      el.style.display = "none";
    }
  });
}

function setLoading(text, progress = "", pct = null) {
  document.getElementById("loading-text").textContent = text;
  document.getElementById("loading-progress").textContent = progress;
  if (pct !== null) {
    document.getElementById("progress-bar").style.width = pct + "%";
  }
}

function showError(msg) {
  const el = document.getElementById("error-msg");
  el.textContent = msg;
  el.style.display = "block";
  document.getElementById("login-btn").disabled = false;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUTH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function init() {
  await msalInstance.initialize();
  const accounts = msalInstance.getAllAccounts();
  if (accounts.length > 0) {
    msalInstance.setActiveAccount(accounts[0]);
    showScreen("loading-screen");
    setLoading("Loading your dataâ€¦", "", 5);
    await fetchAndRender();
  } else {
    showScreen("login-screen");
  }
}

async function login() {
  document.getElementById("login-btn").disabled = true;
  document.getElementById("error-msg").style.display = "none";
  try {
    const result = await msalInstance.loginPopup({ scopes: SCOPES });
    msalInstance.setActiveAccount(result.account);
    showScreen("loading-screen");
    setLoading("Connected! Fetching your inboxâ€¦", "", 5);
    await fetchAndRender();
  } catch (err) {
    showError("Sign-in failed: " + (err.message || err));
  }
}

async function signOut() {
  await msalInstance.logoutPopup();
  showScreen("login-screen");
}

async function getToken() {
  const account = msalInstance.getActiveAccount();
  const res = await msalInstance.acquireTokenSilent({ scopes: SCOPES, account });
  return res.accessToken;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GRAPH API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function fetchAllPages(firstUrl, onCount) {
  const all = [];
  let url = firstUrl;
  while (url) {
    const token = await getToken();
    const resp  = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
    if (!resp.ok) {
      const body = await resp.json().catch(() => ({}));
      throw new Error(body.error?.message || `HTTP ${resp.status}`);
    }
    const data = await resp.json();
    all.push(...(data.value || []));
    if (onCount) onCount(all.length);
    url = data["@odata.nextLink"] || null;
  }
  return all;
}

async function fetchAndRender() {
  const since = new Date();
  if (MONTHS_BACK === 0) {
    since.setHours(0, 0, 0, 0); // today from midnight
  } else {
    since.setMonth(since.getMonth() - MONTHS_BACK);
  }
  const sinceISO = since.toISOString();

  const recFields  = "id,receivedDateTime,from,toRecipients,ccRecipients,subject,conversationId,isRead,hasAttachments,bodyPreview";
  const sentFields = "id,sentDateTime,from,toRecipients,ccRecipients,subject,conversationId,hasAttachments,bodyPreview";

  const recUrl  = `${GRAPH}/me/mailFolders/inbox/messages?$select=${recFields}&$filter=${encodeURIComponent("receivedDateTime ge " + sinceISO)}&$top=100`;
  const sentUrl = `${GRAPH}/me/mailFolders/sentitems/messages?$select=${sentFields}&$filter=${encodeURIComponent("sentDateTime ge " + sinceISO)}&$top=100`;

  try {
    setLoading("Fetching received emailsâ€¦", "startingâ€¦", 10);
    ALL_RECEIVED = await fetchAllPages(recUrl, n => {
      setLoading("Fetching received emailsâ€¦", `${n} messages`, Math.min(10 + n / 25, 45));
    });

    setLoading("Fetching sent emailsâ€¦", "startingâ€¦", 50);
    ALL_SENT = await fetchAllPages(sentUrl, n => {
      setLoading("Fetching sent emailsâ€¦", `${n} messages`, Math.min(50 + n / 25, 85));
    });

    setLoading("Building dashboardâ€¦", "", 95);
    await new Promise(r => setTimeout(r, 300));

    const account = msalInstance.getActiveAccount();
    document.getElementById("account-badge").textContent = account?.username || "";

    renderDashboard(ALL_RECEIVED, ALL_SENT);
    showScreen("dashboard");

  } catch (err) {
    showScreen("login-screen");
    showError("Failed to load data: " + err.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function weekKey(dateStr) {
  const d = new Date(dateStr);
  const day = d.getDay();
  const diff = d.getDate() - day + (day === 0 ? -6 : 1);
  const m = new Date(d);
  m.setDate(diff);
  m.setHours(0, 0, 0, 0);
  return m.toISOString().slice(0, 10);
}

function monthKey(dateStr) {
  const d = new Date(dateStr);
  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}`;
}

function groupByWeek(msgs, field) {
  const map = {};
  msgs.forEach(m => { const k = weekKey(m[field]); map[k] = (map[k] || 0) + 1; });
  return map;
}

function groupByDow(msgs, field) {
  const c = new Array(7).fill(0);
  msgs.forEach(m => c[new Date(m[field]).getDay()]++);
  return c;
}

function groupByHour(msgs, field) {
  const c = new Array(24).fill(0);
  msgs.forEach(m => c[new Date(m[field]).getHours()]++);
  return c;
}

function topN(msgs, keysFn, n = 10) {
  const map = {};
  msgs.forEach(m => {
    keysFn(m).forEach(k => { if (k) map[k] = (map[k] || 0) + 1; });
  });
  return Object.entries(map).sort((a, b) => b[1] - a[1]).slice(0, n);
}

function calcResponseTimes(received, sent) {
  const conv = {};
  received.forEach(m => {
    const id = m.conversationId;
    if (!conv[id]) conv[id] = [];
    conv[id].push(new Date(m.receivedDateTime).getTime());
  });

  const buckets = { "<1h": 0, "1â€“4h": 0, "4â€“24h": 0, "1â€“3d": 0, ">3d": 0 };

  sent.forEach(m => {
    const prev = conv[m.conversationId];
    if (!prev) return;
    const sentT = new Date(m.sentDateTime).getTime();
    const lastRec = prev.filter(t => t < sentT).sort((a, b) => b - a)[0];
    if (!lastRec) return;
    const hrs = (sentT - lastRec) / 3_600_000;
    if (hrs > 7 * 24) return;
    if      (hrs < 1)  buckets["<1h"]++;
    else if (hrs < 4)  buckets["1â€“4h"]++;
    else if (hrs < 24) buckets["4â€“24h"]++;
    else if (hrs < 72) buckets["1â€“3d"]++;
    else               buckets[">3d"]++;
  });

  return buckets;
}

function calcMonthlyReadRate(received) {
  const map = {};
  received.forEach(m => {
    const k = monthKey(m.receivedDateTime);
    if (!map[k]) map[k] = { total: 0, read: 0 };
    map[k].total++;
    if (m.isRead) map[k].read++;
  });
  return Object.entries(map)
    .sort((a, b) => a[0].localeCompare(b[0]))
    .map(([k, v]) => ({
      month: k,
      label: new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" }),
      rate:  v.total > 0 ? Math.round(v.read / v.total * 100) : 0
    }));
}

function calcMonthlyAttachments(received, sent) {
  const map = {};
  const add = (dateStr) => {
    const k = monthKey(dateStr);
    map[k] = (map[k] || 0) + 1;
  };
  received.filter(m => m.hasAttachments).forEach(m => add(m.receivedDateTime));
  sent.filter(m => m.hasAttachments).forEach(m => add(m.sentDateTime));
  const keys = Object.keys(map).sort();
  return {
    months: keys,
    labels: keys.map(k => new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" })),
    data:   keys.map(k => map[k])
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NORMALIZE: turn any message into a table row
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function normalizeMsg(m, type) {
  const dateField = type === "sent" ? "sentDateTime" : "receivedDateTime";
  const dateVal = m[dateField] || m.sentDateTime || m.receivedDateTime;
  return {
    date:       dateVal,
    from:       m.from?.emailAddress?.address || "(you)",
    to:         (m.toRecipients || []).map(r => r.emailAddress?.address).join(", ") || "â€”",
    subject:    m.subject || "(no subject)",
    attachment: m.hasAttachments ? "Yes" : "No",
    _type:      type
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRILL-DOWN MODAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let drillRows = [];
let drillSortCol = "date";
let drillSortAsc = false;

function openDrill(title, emails) {
  drillRows = emails;
  drillSortCol = "date";
  drillSortAsc = false;
  document.getElementById("drill-title").textContent = title;
  document.getElementById("drill-count").textContent = emails.length + " emails";
  renderDrillTable();
  document.getElementById("drill-overlay").classList.add("open");
  document.body.style.overflow = "hidden";
}

function closeDrill() {
  document.getElementById("drill-overlay").classList.remove("open");
  document.body.style.overflow = "";
}

function sortDrill(col) {
  if (drillSortCol === col) {
    drillSortAsc = !drillSortAsc;
  } else {
    drillSortCol = col;
    drillSortAsc = col === "date" ? false : true;
  }
  renderDrillTable();
}

function renderDrillTable() {
  ["date","from","to","subject","attachment"].forEach(c => {
    const el = document.getElementById("sort-" + c);
    if (c === drillSortCol) {
      el.textContent = drillSortAsc ? "â–²" : "â–¼";
    } else {
      el.textContent = "";
    }
  });

  const sorted = [...drillRows].sort((a, b) => {
    let va = a[drillSortCol], vb = b[drillSortCol];
    if (drillSortCol === "date") {
      va = new Date(va).getTime();
      vb = new Date(vb).getTime();
    } else {
      va = (va || "").toLowerCase();
      vb = (vb || "").toLowerCase();
    }
    if (va < vb) return drillSortAsc ? -1 : 1;
    if (va > vb) return drillSortAsc ? 1 : -1;
    return 0;
  });

  const tbody = document.getElementById("drill-tbody");
  tbody.innerHTML = sorted.map(r => {
    const d = new Date(r.date);
    const dateStr = d.toLocaleDateString("en", { month: "short", day: "numeric", year: "numeric" }) +
                    " " + d.toLocaleTimeString("en", { hour: "numeric", minute: "2-digit" });
    const attCls = r.attachment === "Yes" ? "att-yes" : "att-no";
    return `<tr>
      <td style="white-space:nowrap">${dateStr}</td>
      <td title="${r.from}">${r.from}</td>
      <td title="${r.to}">${r.to}</td>
      <td title="${r.subject}">${r.subject}</td>
      <td class="${attCls}">${r.attachment}</td>
    </tr>`;
  }).join("");
}

document.addEventListener("keydown", e => { if (e.key === "Escape") closeDrill(); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRILL-DOWN FILTER HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drillReceived(filterFn, title) {
  const emails = ALL_RECEIVED.filter(filterFn).map(m => normalizeMsg(m, "received"));
  openDrill(title, emails);
}

function drillSent(filterFn, title) {
  const emails = ALL_SENT.filter(filterFn).map(m => normalizeMsg(m, "sent"));
  openDrill(title, emails);
}

function drillBoth(recFilterFn, sentFilterFn, title) {
  const emails = [
    ...ALL_RECEIVED.filter(recFilterFn).map(m => normalizeMsg(m, "received")),
    ...ALL_SENT.filter(sentFilterFn).map(m => normalizeMsg(m, "sent"))
  ];
  openDrill(title, emails);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHART DEFAULTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const BASE_OPTS = {
  responsive: true,
  maintainAspectRatio: false,
  plugins: { legend: { display: false } },
  animation: { duration: 600 }
};

const GRID_COLOR  = "#f0f0f5";
const REC_COLOR   = "#5b6af9";
const SENT_COLOR  = "#f97066";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderDashboard(received, sent) {
  // Update overview label to reflect chosen range
  const lbl = document.getElementById("overview-label");
  if (lbl) {
    const m = MONTHS_BACK;
    if (m === 0)       lbl.textContent = "Today's overview";
    else if (m < 12)   lbl.textContent = `${m}-month overview`;
    else if (m % 12 === 0) lbl.textContent = `${m / 12}-year overview`;
    else               lbl.textContent = `${m}-month overview`;
  }
  renderStats(received, sent);
  renderTimeline(received, sent);
  renderDow(received, sent);
  renderHod(received, sent);
  renderTopSenders(received);
  renderTopRecipients(sent);
  renderResponseTimes(received, sent);
  renderReadRate(received);
  renderAttachments(received, sent);
  // â”€â”€ Engagement analytics â”€â”€
  renderEngagementScore(received, sent);
  renderTaskClassification(received, sent);
  renderTaskTrend(received, sent);
  renderThreadDepth(received, sent);
  renderParticipantDist(received, sent);
  renderEmailLength(received, sent);
  renderStakeholders(received, sent);
  renderResponseTrend(received, sent);
  renderTopSendersOverTime(received, sent);
  renderTopRecipientsOverTime(received, sent);
}

// â”€â”€ Stat cards (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderStats(received, sent) {
  const days = MONTHS_BACK > 0 ? MONTHS_BACK * 30.44 : 1;

  const dowCounts  = groupByDow(received, "receivedDateTime");
  const dowLabels  = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  const busyDowIdx = dowCounts.indexOf(Math.max(...dowCounts));
  const busyDow    = dowLabels[busyDowIdx];

  const hourCounts = groupByHour(received, "receivedDateTime");
  const busyHourN  = hourCounts.indexOf(Math.max(...hourCounts));
  const busyHour   = busyHourN === 0 ? "12am"
    : busyHourN < 12  ? `${busyHourN}am`
    : busyHourN === 12 ? "12pm"
    : `${busyHourN - 12}pm`;

  const recPerDay  = (received.length / days).toFixed(1);
  const sentPerDay = (sent.length / days).toFixed(1);

  const topSender  = topN(received, m => [m.from?.emailAddress?.address || ""], 1);
  const topSenderAddr = topSender[0]?.[0] || "";
  const topSenderDisplay = topSender[0]
    ? topSender[0][0].split("@")[0].replace(/[._]/g, " ")
    : "â€”";

  const attachPct  = received.length > 0
    ? Math.round(received.filter(m => m.hasAttachments).length / received.length * 100)
    : 0;

  const cards = [
    { label: "Received",         value: received.length.toLocaleString(), sub: `${recPerDay}/day avg`,  cls: "c-received",
      onclick: `drillReceived(() => true, 'All Received Emails')` },
    { label: "Sent",             value: sent.length.toLocaleString(),     sub: `${sentPerDay}/day avg`, cls: "c-sent",
      onclick: `drillSent(() => true, 'All Sent Emails')` },
    { label: "Busiest Day",      value: busyDow,    sub: "for incoming mail", cls: "",
      onclick: `drillReceived(m => new Date(m.receivedDateTime).getDay() === ${busyDowIdx}, 'Received on ${busyDow}s')` },
    { label: "Busiest Hour",     value: busyHour,   sub: "most mail arrives", cls: "",
      onclick: `drillReceived(m => new Date(m.receivedDateTime).getHours() === ${busyHourN}, 'Received at ${busyHour}')` },
    { label: "Top Sender",       value: topSenderDisplay, sub: topSenderAddr, cls: "",
      onclick: `drillReceived(m => m.from?.emailAddress?.address === '${topSenderAddr}', 'From ${topSenderAddr}')` },
    { label: "With Attachments", value: `${attachPct}%`, sub: "of received have files", cls: "",
      onclick: `drillReceived(m => m.hasAttachments, 'Received with Attachments')` },
  ];

  document.getElementById("stats-grid").innerHTML = cards.map(c => `
    <div class="stat-card ${c.cls}" onclick="${c.onclick}">
      <div class="stat-label">${c.label}</div>
      <div class="stat-value">${c.value}</div>
      <div class="stat-sub">${c.sub}</div>
    </div>
  `).join("");
}

// â”€â”€ Timeline (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTimeline(received, sent) {
  const recW  = groupByWeek(received, "receivedDateTime");
  const sentW = groupByWeek(sent, "sentDateTime");
  const keys  = [...new Set([...Object.keys(recW), ...Object.keys(sentW)])].sort();
  const labels = keys.map(k => {
    const d = new Date(k);
    return d.toLocaleDateString("en", { month: "short", day: "numeric" });
  });

  new Chart(document.getElementById("c-timeline"), {
    type: "line",
    data: {
      labels,
      datasets: [
        {
          label: "Received",
          data: keys.map(k => recW[k] || 0),
          borderColor: REC_COLOR,
          backgroundColor: REC_COLOR + "18",
          fill: true, tension: 0.4, pointRadius: 0, borderWidth: 2
        },
        {
          label: "Sent",
          data: keys.map(k => sentW[k] || 0),
          borderColor: SENT_COLOR,
          backgroundColor: SENT_COLOR + "18",
          fill: true, tension: 0.4, pointRadius: 0, borderWidth: 2
        }
      ]
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const wk = keys[idx];
        const label = labels[idx];
        drillBoth(
          m => weekKey(m.receivedDateTime) === wk,
          m => weekKey(m.sentDateTime) === wk,
          `Week of ${label}`
        );
      },
      plugins: {
        legend: { display: false },
        tooltip: { mode: "index", intersect: false }
      },
      scales: {
        x: { grid: { display: false }, ticks: { maxTicksLimit: 14, font: { size: 11 } } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true }
      }
    }
  });
}

// â”€â”€ Day of week (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderDow(received, sent) {
  const labels = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  new Chart(document.getElementById("c-dow"), {
    type: "bar",
    data: {
      labels,
      datasets: [
        { label: "Received", data: groupByDow(received, "receivedDateTime"), backgroundColor: REC_COLOR + "cc",  borderRadius: 5 },
        { label: "Sent",     data: groupByDow(sent, "sentDateTime"),          backgroundColor: SENT_COLOR + "cc", borderRadius: 5 }
      ]
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const dsIdx = elems[0].datasetIndex;
        const day = labels[idx];
        if (dsIdx === 0) {
          drillReceived(m => new Date(m.receivedDateTime).getDay() === idx, `Received on ${day}s`);
        } else {
          drillSent(m => new Date(m.sentDateTime).getDay() === idx, `Sent on ${day}s`);
        }
      },
      plugins: { legend: { display: true, labels: { boxWidth: 10, font: { size: 11 } } } },
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true }
      }
    }
  });
}

// â”€â”€ Hour of day (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderHod(received, sent) {
  const labels = Array.from({ length: 24 }, (_, i) =>
    i === 0 ? "12am" : i < 12 ? `${i}am` : i === 12 ? "12pm" : `${i-12}pm`
  );
  new Chart(document.getElementById("c-hod"), {
    type: "bar",
    data: {
      labels,
      datasets: [
        { label: "Received", data: groupByHour(received, "receivedDateTime"), backgroundColor: REC_COLOR + "cc",  borderRadius: 3 },
        { label: "Sent",     data: groupByHour(sent, "sentDateTime"),          backgroundColor: SENT_COLOR + "cc", borderRadius: 3 }
      ]
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const dsIdx = elems[0].datasetIndex;
        const hr = labels[idx];
        if (dsIdx === 0) {
          drillReceived(m => new Date(m.receivedDateTime).getHours() === idx, `Received at ${hr}`);
        } else {
          drillSent(m => new Date(m.sentDateTime).getHours() === idx, `Sent at ${hr}`);
        }
      },
      plugins: { legend: { display: true, labels: { boxWidth: 10, font: { size: 11 } } } },
      scales: {
        x: { grid: { display: false }, ticks: { maxTicksLimit: 8, font: { size: 11 } } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true }
      }
    }
  });
}

// â”€â”€ Top senders (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTopSenders(received) {
  const top = topN(received, m => [m.from?.emailAddress?.address || ""], 10);
  new Chart(document.getElementById("c-senders"), {
    type: "bar",
    data: {
      labels: top.map(([k]) => k.split("@")[0]),
      datasets: [{ data: top.map(([,v]) => v), backgroundColor: REC_COLOR + "cc", borderRadius: 4 }]
    },
    options: {
      ...BASE_OPTS,
      indexAxis: "y",
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const addr = top[idx][0];
        drillReceived(m => m.from?.emailAddress?.address === addr, `From ${addr}`);
      },
      scales: {
        x: { grid: { color: GRID_COLOR }, beginAtZero: true },
        y: { grid: { display: false }, ticks: { font: { size: 11 } } }
      }
    }
  });
}

// â”€â”€ Top recipients (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTopRecipients(sent) {
  const top = topN(sent, m => (m.toRecipients || []).map(r => r.emailAddress?.address || ""), 10);
  new Chart(document.getElementById("c-recipients"), {
    type: "bar",
    data: {
      labels: top.map(([k]) => k.split("@")[0]),
      datasets: [{ data: top.map(([,v]) => v), backgroundColor: SENT_COLOR + "cc", borderRadius: 4 }]
    },
    options: {
      ...BASE_OPTS,
      indexAxis: "y",
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const addr = top[idx][0];
        drillSent(m => (m.toRecipients || []).some(r => r.emailAddress?.address === addr), `To ${addr}`);
      },
      scales: {
        x: { grid: { color: GRID_COLOR }, beginAtZero: true },
        y: { grid: { display: false }, ticks: { font: { size: 11 } } }
      }
    }
  });
}

// â”€â”€ Response times (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderResponseTimes(received, sent) {
  const buckets = calcResponseTimes(received, sent);
  const colors  = ["#22c55e","#84cc16","#f59e0b","#f97066","#ef4444"];
  const bucketKeys = Object.keys(buckets);
  const thresholds = [[0,1],[1,4],[4,24],[24,72],[72,7*24]];

  const conv = {};
  received.forEach(m => {
    const id = m.conversationId;
    if (!conv[id]) conv[id] = [];
    conv[id].push(new Date(m.receivedDateTime).getTime());
  });

  new Chart(document.getElementById("c-response"), {
    type: "bar",
    data: {
      labels: bucketKeys,
      datasets: [{
        data: Object.values(buckets),
        backgroundColor: colors,
        borderRadius: 5
      }]
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const [lo, hi] = thresholds[idx];
        const label = bucketKeys[idx];
        const matchingSent = ALL_SENT.filter(m => {
          const prev = conv[m.conversationId];
          if (!prev) return false;
          const sentT = new Date(m.sentDateTime).getTime();
          const lastRec = prev.filter(t => t < sentT).sort((a, b) => b - a)[0];
          if (!lastRec) return false;
          const hrs = (sentT - lastRec) / 3_600_000;
          if (hrs > 7 * 24) return false;
          return hrs >= lo && hrs < hi;
        });
        openDrill(`Replies in ${label}`, matchingSent.map(m => normalizeMsg(m, "sent")));
      },
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â”€â”€ Read rate (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderReadRate(received) {
  const monthly = calcMonthlyReadRate(received);
  new Chart(document.getElementById("c-readrate"), {
    type: "bar",
    data: {
      labels: monthly.map(m => m.label),
      datasets: [{
        label: "Read %",
        data: monthly.map(m => m.rate),
        backgroundColor: monthly.map(m =>
          m.rate >= 80 ? "#22c55e99" : m.rate >= 50 ? "#f59e0b99" : "#f9706699"
        ),
        borderRadius: 4
      }]
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const mk = monthly[idx].month;
        const label = monthly[idx].label;
        drillReceived(m => monthKey(m.receivedDateTime) === mk, `Received in ${label}`);
      },
      scales: {
        x: { grid: { display: false }, ticks: { font: { size: 11 } } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, max: 100, ticks: { callback: v => v + "%" } }
      },
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: ctx => `${ctx.raw}% opened` } }
      }
    }
  });
}

// â”€â”€ Attachments (clickable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderAttachments(received, sent) {
  const { months, labels, data } = calcMonthlyAttachments(received, sent);
  new Chart(document.getElementById("c-attachments"), {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: "Emails with attachments",
        data,
        backgroundColor: "#a78bfa99",
        borderRadius: 5
      }]
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const idx = elems[0].index;
        const mk = months[idx];
        const label = labels[idx];
        drillBoth(
          m => m.hasAttachments && monthKey(m.receivedDateTime) === mk,
          m => m.hasAttachments && monthKey(m.sentDateTime) === mk,
          `Emails with attachments in ${label}`
        );
      },
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TASK CLASSIFICATION â€” keyword scoring
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TASK_CATEGORIES = {
  "Sales":         ["sales","proposal","deal","client","prospect","pipeline","revenue","pricing","quote","offer","opportunity","customer","demo","pitch","crm","lead","account","contract renewal","upsell","cross-sell"],
  "Fundraising":   ["fundrais","investor","round","series a","series b","term sheet","cap table","vc","venture","valuation","due diligence","raise capital","investment","angel","spv","convertible","safe note"],
  "Hiring":        ["interview","candidate","hiring","recruit","offer letter","onboard","job","position","cv","resume","applicant","talent","headcount","role","hc "],
  "Finance":       ["invoice","payment","budget","expense","receipt","accounting","payroll","tax","reimburs","purchase order","p&l","cashflow","forecast","runway","burn"],
  "Legal":         ["contract","agreement","legal","compliance","nda","terms","gdpr","policy","liability","clause","ip ","trademark","copyright","litigation","dispute"],
  "1:1 / Sync":    ["1:1","one on one","one-on-one","catch up","catch-up","check-in","check in","weekly sync","standup","stand-up","bi-weekly","monthly review","feedback","skip"],
  "Internal":      ["all hands","all-hands","company update","announcement","team meeting","office","holiday","ooo","out of office","internal","company wide","company-wide"],
};

function classifySubject(subject) {
  const s = (subject || "").toLowerCase();
  // Score each category
  for (const [cat, keywords] of Object.entries(TASK_CATEGORIES)) {
    if (keywords.some(k => s.includes(k))) return cat;
  }
  return "Project / Other";
}

function calcTaskDistribution(received, sent) {
  const map = {};
  const allEmails = [
    ...received.map(m => ({ subject: m.subject, msg: m, type: "received" })),
    ...sent.map(m => ({ subject: m.subject, msg: m, type: "sent" }))
  ];
  allEmails.forEach(({ subject, msg, type }) => {
    const cat = classifySubject(subject);
    if (!map[cat]) map[cat] = { count: 0, received: [], sent: [] };
    map[cat].count++;
    map[cat][type].push(msg);
  });
  return map;
}

function calcMonthlyTaskTrend(received, sent) {
  // Returns { month -> { category -> count } }
  const months = {};
  const addMsg = (m, dateField) => {
    const mk = monthKey(m[dateField]);
    if (!months[mk]) months[mk] = {};
    const cat = classifySubject(m.subject);
    months[mk][cat] = (months[mk][cat] || 0) + 1;
  };
  received.forEach(m => addMsg(m, "receivedDateTime"));
  sent.forEach(m => addMsg(m, "sentDateTime"));
  return months;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THREAD ANALYTICS â€” group by conversationId
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildThreadMap(received, sent) {
  // Returns map of conversationId -> { messages[], participants Set, firstDate, lastDate }
  const threads = {};
  const addToThread = (m, dateField) => {
    const id = m.conversationId;
    if (!id) return;
    if (!threads[id]) threads[id] = { messages: [], participants: new Set(), firstDate: null, lastDate: null };
    threads[id].messages.push(m);
    const t = new Date(m[dateField]).getTime();
    if (!threads[id].firstDate || t < threads[id].firstDate) threads[id].firstDate = t;
    if (!threads[id].lastDate  || t > threads[id].lastDate)  threads[id].lastDate  = t;
    // collect participants
    const from = m.from?.emailAddress?.address;
    if (from) threads[id].participants.add(from);
    (m.toRecipients || []).forEach(r => { const a = r.emailAddress?.address; if (a) threads[id].participants.add(a); });
    (m.ccRecipients || []).forEach(r => { const a = r.emailAddress?.address; if (a) threads[id].participants.add(a); });
  };
  received.forEach(m => addToThread(m, "receivedDateTime"));
  sent.forEach(m => addToThread(m, "sentDateTime"));
  return threads;
}

function calcThreadStats(received, sent) {
  const threads = buildThreadMap(received, sent);
  const depths = Object.values(threads).map(t => t.messages.length);
  const participants = Object.values(threads).map(t => t.participants.size);
  const durations = Object.values(threads)
    .filter(t => t.firstDate && t.lastDate && t.lastDate > t.firstDate)
    .map(t => (t.lastDate - t.firstDate) / (1000 * 60 * 60 * 24)); // days

  const threadCount = depths.length;
  const avgDepth = threadCount ? (depths.reduce((a, b) => a + b, 0) / threadCount).toFixed(1) : 0;
  const avgParticipants = threadCount ? (participants.reduce((a, b) => a + b, 0) / threadCount).toFixed(1) : 0;

  // depth distribution buckets
  const depthBuckets = { "1 msg": 0, "2â€“3": 0, "4â€“7": 0, "8â€“15": 0, "16+": 0 };
  depths.forEach(d => {
    if      (d === 1)  depthBuckets["1 msg"]++;
    else if (d <= 3)   depthBuckets["2â€“3"]++;
    else if (d <= 7)   depthBuckets["4â€“7"]++;
    else if (d <= 15)  depthBuckets["8â€“15"]++;
    else               depthBuckets["16+"]++;
  });

  // participant distribution buckets
  const partBuckets = { "1:1": 0, "3â€“5": 0, "6â€“10": 0, "11â€“20": 0, "20+": 0 };
  participants.forEach(p => {
    if      (p <= 2)  partBuckets["1:1"]++;
    else if (p <= 5)  partBuckets["3â€“5"]++;
    else if (p <= 10) partBuckets["6â€“10"]++;
    else if (p <= 20) partBuckets["11â€“20"]++;
    else              partBuckets["20+"]++;
  });

  return { threadCount, avgDepth, avgParticipants, depthBuckets, partBuckets };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EMAIL LENGTH â€” word count from bodyPreview
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function estimateWordCount(bodyPreview) {
  if (!bodyPreview) return 0;
  return bodyPreview.trim().split(/\s+/).filter(w => w.length > 0).length;
}

function calcMonthlyEmailLength(received, sent) {
  // avg estimated word count per month, sent vs received
  const recMap = {}, sentMap = {};
  received.forEach(m => {
    const k = monthKey(m.receivedDateTime);
    if (!recMap[k]) recMap[k] = [];
    recMap[k].push(estimateWordCount(m.bodyPreview));
  });
  sent.forEach(m => {
    const k = monthKey(m.sentDateTime);
    if (!sentMap[k]) sentMap[k] = [];
    sentMap[k].push(estimateWordCount(m.bodyPreview));
  });
  const allKeys = [...new Set([...Object.keys(recMap), ...Object.keys(sentMap)])].sort();
  const avg = arr => arr.length ? Math.round(arr.reduce((a, b) => a + b, 0) / arr.length) : 0;
  return {
    labels: allKeys.map(k => new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" })),
    recAvg: allKeys.map(k => avg(recMap[k] || [])),
    sentAvg: allKeys.map(k => avg(sentMap[k] || []))
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STAKEHOLDER VARIETY â€” unique contacts per month
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calcMonthlyStakeholders(received, sent) {
  const map = {};
  received.forEach(m => {
    const k = monthKey(m.receivedDateTime);
    if (!map[k]) map[k] = new Set();
    const addr = m.from?.emailAddress?.address;
    if (addr) map[k].add(addr);
  });
  sent.forEach(m => {
    const k = monthKey(m.sentDateTime);
    if (!map[k]) map[k] = new Set();
    (m.toRecipients || []).forEach(r => { const a = r.emailAddress?.address; if (a) map[k].add(a); });
    (m.ccRecipients || []).forEach(r => { const a = r.emailAddress?.address; if (a) map[k].add(a); });
  });
  const keys = Object.keys(map).sort();
  return {
    labels: keys.map(k => new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" })),
    counts: keys.map(k => map[k].size)
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOP CONTACTS OVER TIME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calcTopContactsOverTime(received, sent, n = 5) {
  // For each month, who are top n senders and recipients?
  const recByMonth = {}, sentByMonth = {};
  received.forEach(m => {
    const k = monthKey(m.receivedDateTime);
    const addr = m.from?.emailAddress?.address;
    if (!addr) return;
    if (!recByMonth[k]) recByMonth[k] = {};
    recByMonth[k][addr] = (recByMonth[k][addr] || 0) + 1;
  });
  sent.forEach(m => {
    const k = monthKey(m.sentDateTime);
    (m.toRecipients || []).forEach(r => {
      const addr = r.emailAddress?.address;
      if (!addr) return;
      if (!sentByMonth[k]) sentByMonth[k] = {};
      sentByMonth[k][addr] = (sentByMonth[k][addr] || 0) + 1;
    });
  });
  const months = [...new Set([...Object.keys(recByMonth), ...Object.keys(sentByMonth)])].sort();

  // Build top-n senders per month as stacked data
  const topRecAddrs = Object.keys(
    received.reduce((acc, m) => {
      const a = m.from?.emailAddress?.address; if (a) acc[a] = (acc[a] || 0) + 1; return acc;
    }, {})
  ).sort((a, b) =>
    (received.filter(m => m.from?.emailAddress?.address === b).length) -
    (received.filter(m => m.from?.emailAddress?.address === a).length)
  ).slice(0, n);

  const topSentAddrs = Object.keys(
    sent.reduce((acc, m) => {
      (m.toRecipients || []).forEach(r => { const a = r.emailAddress?.address; if (a) acc[a] = (acc[a] || 0) + 1; }); return acc;
    }, {})
  ).sort((a, b) => {
    const bCount = sent.filter(m => (m.toRecipients||[]).some(r=>r.emailAddress?.address===b)).length;
    const aCount = sent.filter(m => (m.toRecipients||[]).some(r=>r.emailAddress?.address===a)).length;
    return bCount - aCount;
  }).slice(0, n);

  return {
    months,
    labels: months.map(k => new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" })),
    topRecAddrs,
    topSentAddrs,
    recByMonth,
    sentByMonth
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENGAGEMENT SCORE â€” monthly composite 0â€“100
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calcEngagementScore(received, sent) {
  // Per-month score from 4 signals:
  // 1. Reply rate (% of received convos that got a reply from you)
  // 2. Response speed (inverse of avg hours to reply, capped at 48h)
  // 3. Initiation rate (% of sent emails that start a NEW conversation)
  // 4. Network breadth (unique contacts contacted, normalised)

  const months = [...new Set([
    ...received.map(m => monthKey(m.receivedDateTime)),
    ...sent.map(m => monthKey(m.sentDateTime))
  ])].sort();

  // Build conversation lookup
  const convRecTimes = {}; // convId -> [timestamps of received]
  received.forEach(m => {
    const id = m.conversationId; if (!id) return;
    if (!convRecTimes[id]) convRecTimes[id] = [];
    convRecTimes[id].push(new Date(m.receivedDateTime).getTime());
  });

  const scores = months.map(mk => {
    const recMonth  = received.filter(m => monthKey(m.receivedDateTime) === mk);
    const sentMonth = sent.filter(m => monthKey(m.sentDateTime) === mk);
    if (recMonth.length + sentMonth.length < 5) return null; // not enough data

    // 1. Reply rate
    const recConvIds = new Set(recMonth.map(m => m.conversationId).filter(Boolean));
    const repliedConvIds = new Set(
      sentMonth.filter(m => recConvIds.has(m.conversationId)).map(m => m.conversationId)
    );
    const replyRate = recConvIds.size > 0 ? repliedConvIds.size / recConvIds.size : 0;

    // 2. Response speed: avg hours to reply (lower = better)
    const responseTimes = [];
    sentMonth.forEach(m => {
      const prev = convRecTimes[m.conversationId];
      if (!prev) return;
      const sentT = new Date(m.sentDateTime).getTime();
      const lastRec = prev.filter(t => t < sentT).sort((a, b) => b - a)[0];
      if (!lastRec) return;
      const hrs = (sentT - lastRec) / 3_600_000;
      if (hrs <= 48) responseTimes.push(hrs);
    });
    const avgHrs = responseTimes.length > 0
      ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length : 24;
    const speedScore = Math.max(0, 1 - (avgHrs / 48)); // 0h=1.0, 48h=0.0

    // 3. Initiation rate (sent emails whose conv has NO received message)
    const initiatedConvIds = sentMonth.filter(m =>
      m.conversationId && !convRecTimes[m.conversationId]
    ).length;
    const initiationRate = sentMonth.length > 0 ? initiatedConvIds / sentMonth.length : 0;

    // 4. Network breadth: unique contacts this month (normalised vs max across all months)
    const contacts = new Set();
    recMonth.forEach(m => { const a = m.from?.emailAddress?.address; if (a) contacts.add(a); });
    sentMonth.forEach(m => {
      (m.toRecipients||[]).forEach(r => { const a = r.emailAddress?.address; if (a) contacts.add(a); });
    });
    const breadth = contacts.size; // raw, normalised later

    // weighted composite (breadth normalised after collecting all months)
    return { mk, replyRate, speedScore, initiationRate, breadth, label:
      new Date(mk + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" }) };
  }).filter(Boolean);

  if (scores.length === 0) return [];

  const maxBreadth = Math.max(...scores.map(s => s.breadth), 1);
  return scores.map(s => {
    const breadthScore = s.breadth / maxBreadth;
    const composite = (
      s.replyRate     * 35 +
      s.speedScore    * 30 +
      s.initiationRate * 15 +
      breadthScore    * 20
    ); // already 0â€“100 scale
    return { mk: s.mk, label: s.label, score: Math.round(composite) };
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESPONSE TIME TREND â€” rolling monthly avg hours
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calcMonthlyResponseTrend(received, sent) {
  const convRecTimes = {};
  received.forEach(m => {
    const id = m.conversationId; if (!id) return;
    if (!convRecTimes[id]) convRecTimes[id] = [];
    convRecTimes[id].push(new Date(m.receivedDateTime).getTime());
  });

  const map = {};
  sent.forEach(m => {
    const prev = convRecTimes[m.conversationId];
    if (!prev) return;
    const sentT = new Date(m.sentDateTime).getTime();
    const lastRec = prev.filter(t => t < sentT).sort((a, b) => b - a)[0];
    if (!lastRec) return;
    const hrs = (sentT - lastRec) / 3_600_000;
    if (hrs > 7 * 24) return;
    const mk = monthKey(m.sentDateTime);
    if (!map[mk]) map[mk] = [];
    map[mk].push(hrs);
  });

  const keys = Object.keys(map).sort();
  const avg = arr => arr.length ? (arr.reduce((a, b) => a + b, 0) / arr.length).toFixed(1) : null;
  return {
    labels: keys.map(k => new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" })),
    avgHours: keys.map(k => avg(map[k]))
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW CHART RENDERERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Engagement Score over time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderEngagementScore(received, sent) {
  const scores = calcEngagementScore(received, sent);
  if (!scores.length) return;

  new Chart(document.getElementById("c-engagement"), {
    type: "line",
    data: {
      labels: scores.map(s => s.label),
      datasets: [{
        label: "Engagement Score",
        data: scores.map(s => s.score),
        borderColor: "#22c55e",
        backgroundColor: "rgba(34,197,94,0.1)",
        fill: true, tension: 0.4, pointRadius: 4,
        pointBackgroundColor: "#22c55e", borderWidth: 2
      }]
    },
    options: {
      ...BASE_OPTS,
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, max: 100,
             ticks: { callback: v => v } }
      },
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: ctx => `Score: ${ctx.raw}/100` } }
      }
    }
  });

  // Update stat card
  const latest = scores[scores.length - 1];
  const prev   = scores[scores.length - 2];
  const el = document.getElementById("engagement-stat");
  if (el && latest) {
    const trend = prev ? (latest.score > prev.score ? "â†‘" : latest.score < prev.score ? "â†“" : "â†’") : "";
    el.innerHTML = `<div class="stat-label">Engagement Score</div>
      <div class="stat-value" style="color:#22c55e">${latest.score}</div>
      <div class="stat-sub">${trend} vs last month Â· out of 100</div>`;
  }
}

// â”€â”€ Task classification donut â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TASK_COLORS = {
  "Sales":         "#6366f1",
  "Fundraising":   "#f59e0b",
  "Hiring":        "#06b6d4",
  "Finance":       "#84cc16",
  "Legal":         "#f97066",
  "1:1 / Sync":    "#a78bfa",
  "Internal":      "#94a3b8",
  "Project / Other": "#5b6af9"
};

function renderTaskClassification(received, sent) {
  const dist = calcTaskDistribution(received, sent);
  const entries = Object.entries(dist).sort((a, b) => b[1].count - a[1].count);

  new Chart(document.getElementById("c-tasks"), {
    type: "doughnut",
    data: {
      labels: entries.map(([k]) => k),
      datasets: [{
        data: entries.map(([,v]) => v.count),
        backgroundColor: entries.map(([k]) => TASK_COLORS[k] || "#94a3b8"),
        borderWidth: 2,
        borderColor: "#fff"
      }]
    },
    options: {
      ...BASE_OPTS,
      cutout: "62%",
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const cat = entries[elems[0].index][0];
        const data = dist[cat];
        openDrill(`Category: ${cat}`, [
          ...data.received.map(m => normalizeMsg(m, "received")),
          ...data.sent.map(m => normalizeMsg(m, "sent"))
        ]);
      },
      plugins: {
        legend: { display: true, position: "right",
          labels: { boxWidth: 11, font: { size: 11 }, padding: 10 } },
        tooltip: {
          callbacks: {
            label: ctx => {
              const total = entries.reduce((s, [,v]) => s + v.count, 0);
              const pct = total > 0 ? Math.round(ctx.raw / total * 100) : 0;
              return ` ${ctx.raw} emails (${pct}%)`;
            }
          }
        }
      }
    }
  });
}

// â”€â”€ Monthly task trend (stacked bar) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTaskTrend(received, sent) {
  const monthly = calcMonthlyTaskTrend(received, sent);
  const months = Object.keys(monthly).sort();
  const cats = Object.keys(TASK_COLORS);
  const labels = months.map(k => new Date(k + "-15").toLocaleDateString("en", { month: "short", year: "2-digit" }));

  new Chart(document.getElementById("c-task-trend"), {
    type: "bar",
    data: {
      labels,
      datasets: cats.map(cat => ({
        label: cat,
        data: months.map(mk => monthly[mk]?.[cat] || 0),
        backgroundColor: (TASK_COLORS[cat] || "#94a3b8") + "cc",
        borderRadius: 2
      }))
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const mi = elems[0].index;
        const di = elems[0].datasetIndex;
        const mk = months[mi];
        const cat = cats[di];
        const dist = calcTaskDistribution(
          received.filter(m => monthKey(m.receivedDateTime) === mk),
          sent.filter(m => monthKey(m.sentDateTime) === mk)
        );
        const data = dist[cat] || { received: [], sent: [] };
        openDrill(`${cat} â€” ${labels[mi]}`, [
          ...data.received.map(m => normalizeMsg(m, "received")),
          ...data.sent.map(m => normalizeMsg(m, "sent"))
        ]);
      },
      plugins: {
        legend: { display: true, labels: { boxWidth: 10, font: { size: 10 }, padding: 8 } }
      },
      scales: {
        x: { stacked: true, grid: { display: false }, ticks: { font: { size: 10 } } },
        y: { stacked: true, grid: { color: GRID_COLOR }, beginAtZero: true }
      }
    }
  });
}

// â”€â”€ Thread depth distribution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderThreadDepth(received, sent) {
  const { depthBuckets } = calcThreadStats(received, sent);
  const labels = Object.keys(depthBuckets);
  const colors = ["#e2e8f0","#a78bfa","#6366f1","#4f46e5","#312e81"];

  new Chart(document.getElementById("c-thread-depth"), {
    type: "bar",
    data: {
      labels,
      datasets: [{ data: Object.values(depthBuckets), backgroundColor: colors, borderRadius: 5 }]
    },
    options: {
      ...BASE_OPTS,
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â”€â”€ Participant count distribution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderParticipantDist(received, sent) {
  const { partBuckets } = calcThreadStats(received, sent);
  const labels = Object.keys(partBuckets);
  const colors = ["#bbf7d0","#6ee7b7","#34d399","#059669","#065f46"];

  new Chart(document.getElementById("c-participants"), {
    type: "bar",
    data: {
      labels,
      datasets: [{ data: Object.values(partBuckets), backgroundColor: colors, borderRadius: 5 }]
    },
    options: {
      ...BASE_OPTS,
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â”€â”€ Email length over time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderEmailLength(received, sent) {
  const { labels, recAvg, sentAvg } = calcMonthlyEmailLength(received, sent);
  new Chart(document.getElementById("c-email-length"), {
    type: "line",
    data: {
      labels,
      datasets: [
        { label: "Received (avg words)", data: recAvg, borderColor: REC_COLOR,
          backgroundColor: REC_COLOR + "15", fill: true, tension: 0.4, pointRadius: 3, borderWidth: 2 },
        { label: "Sent (avg words)", data: sentAvg, borderColor: SENT_COLOR,
          backgroundColor: SENT_COLOR + "15", fill: true, tension: 0.4, pointRadius: 3, borderWidth: 2 }
      ]
    },
    options: {
      ...BASE_OPTS,
      plugins: {
        legend: { display: true, labels: { boxWidth: 10, font: { size: 11 } } },
        tooltip: { callbacks: { label: ctx => `${ctx.dataset.label}: ~${ctx.raw} words` } }
      },
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true,
             ticks: { callback: v => v + "w" } }
      }
    }
  });
}

// â”€â”€ Unique stakeholders per month â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderStakeholders(received, sent) {
  const { labels, counts } = calcMonthlyStakeholders(received, sent);
  new Chart(document.getElementById("c-stakeholders"), {
    type: "line",
    data: {
      labels,
      datasets: [{
        label: "Unique contacts",
        data: counts,
        borderColor: "#06b6d4",
        backgroundColor: "rgba(6,182,212,0.1)",
        fill: true, tension: 0.4, pointRadius: 3, borderWidth: 2
      }]
    },
    options: {
      ...BASE_OPTS,
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: ctx => `${ctx.raw} unique contacts` } }
      },
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â”€â”€ Response time trend (monthly avg hours) â”€â”€â”€â”€â”€â”€
function renderResponseTrend(received, sent) {
  const { labels, avgHours } = calcMonthlyResponseTrend(received, sent);
  new Chart(document.getElementById("c-response-trend"), {
    type: "line",
    data: {
      labels,
      datasets: [{
        label: "Avg reply time (hrs)",
        data: avgHours,
        borderColor: "#f59e0b",
        backgroundColor: "rgba(245,158,11,0.1)",
        fill: true, tension: 0.4, pointRadius: 3, borderWidth: 2
      }]
    },
    options: {
      ...BASE_OPTS,
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: ctx => `${ctx.raw}h avg reply time` } }
      },
      scales: {
        x: { grid: { display: false } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true,
             ticks: { callback: v => v + "h" } }
      }
    }
  });
}

// â”€â”€ Top senders over time (line per contact) â”€â”€â”€â”€â”€
function renderTopSendersOverTime(received, sent) {
  const { months, labels, topRecAddrs, recByMonth } = calcTopContactsOverTime(received, sent, 5);
  const palette = ["#6366f1","#f97066","#22c55e","#f59e0b","#06b6d4"];

  new Chart(document.getElementById("c-senders-trend"), {
    type: "line",
    data: {
      labels,
      datasets: topRecAddrs.map((addr, i) => ({
        label: addr.split("@")[0],
        data: months.map(mk => recByMonth[mk]?.[addr] || 0),
        borderColor: palette[i % palette.length],
        backgroundColor: "transparent",
        tension: 0.4, pointRadius: 3, borderWidth: 2
      }))
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const addr = topRecAddrs[elems[0].datasetIndex];
        const mi = elems[0].index;
        const mk = months[mi];
        const label = labels[mi];
        drillReceived(
          m => m.from?.emailAddress?.address === addr && monthKey(m.receivedDateTime) === mk,
          `From ${addr} â€” ${label}`
        );
      },
      plugins: {
        legend: { display: true, labels: { boxWidth: 10, font: { size: 10 }, padding: 8 } }
      },
      scales: {
        x: { grid: { display: false }, ticks: { font: { size: 10 } } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â”€â”€ Top recipients over time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTopRecipientsOverTime(received, sent) {
  const { months, labels, topSentAddrs, sentByMonth } = calcTopContactsOverTime(received, sent, 5);
  const palette = ["#f97066","#6366f1","#f59e0b","#22c55e","#a78bfa"];

  new Chart(document.getElementById("c-recipients-trend"), {
    type: "line",
    data: {
      labels,
      datasets: topSentAddrs.map((addr, i) => ({
        label: addr.split("@")[0],
        data: months.map(mk => sentByMonth[mk]?.[addr] || 0),
        borderColor: palette[i % palette.length],
        backgroundColor: "transparent",
        tension: 0.4, pointRadius: 3, borderWidth: 2
      }))
    },
    options: {
      ...BASE_OPTS,
      onClick: (evt, elems) => {
        if (!elems.length) return;
        const addr = topSentAddrs[elems[0].datasetIndex];
        const mi = elems[0].index;
        const mk = months[mi];
        const label = labels[mi];
        drillSent(
          m => (m.toRecipients||[]).some(r => r.emailAddress?.address === addr) && monthKey(m.sentDateTime) === mk,
          `To ${addr} â€” ${label}`
        );
      },
      plugins: {
        legend: { display: true, labels: { boxWidth: 10, font: { size: 10 }, padding: 8 } }
      },
      scales: {
        x: { grid: { display: false }, ticks: { font: { size: 10 } } },
        y: { grid: { color: GRID_COLOR }, beginAtZero: true, ticks: { precision: 0 } }
      }
    }
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RADIAL TIME SLIDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SL = { cx: 120, cy: 120, r: 88 };
let sliderDragging = false;

function sliderFormat(m) {
  if (m === 0) return "Today";
  if (m < 12)  return `${m}mo`;
  const y  = Math.floor(m / 12);
  const mo = m % 12;
  if (mo === 0) return `${y}yr`;
  return `${y}yr ${mo}mo`;
}

function sliderArcPath(months) {
  if (months <= 0) return "";
  if (months >= 48) {
    // Full circle: two semicircles (SVG can't do a single-command full circle)
    return `M ${SL.cx} ${SL.cy - SL.r} A ${SL.r} ${SL.r} 0 0 1 ${SL.cx} ${SL.cy + SL.r} A ${SL.r} ${SL.r} 0 0 1 ${SL.cx} ${SL.cy - SL.r}`;
  }
  const startRad = -Math.PI / 2;                          // 12 o'clock
  const endRad   = startRad + (months / 48) * 2 * Math.PI; // clockwise
  const sx = SL.cx + SL.r * Math.cos(startRad);
  const sy = SL.cy + SL.r * Math.sin(startRad);
  const ex = SL.cx + SL.r * Math.cos(endRad);
  const ey = SL.cy + SL.r * Math.sin(endRad);
  const large = months > 24 ? 1 : 0;
  return `M ${sx.toFixed(3)} ${sy.toFixed(3)} A ${SL.r} ${SL.r} 0 ${large} 1 ${ex.toFixed(3)} ${ey.toFixed(3)}`;
}

function sliderHandlePos(months) {
  const rad = -Math.PI / 2 + (months / 48) * 2 * Math.PI;
  return {
    x: SL.cx + SL.r * Math.cos(rad),
    y: SL.cy + SL.r * Math.sin(rad)
  };
}

function updateSlider(months) {
  MONTHS_BACK = Math.max(0, Math.min(48, months));

  const arc    = document.getElementById("slider-arc");
  const handle = document.getElementById("slider-handle");
  const main   = document.getElementById("slider-main");
  const sub    = document.getElementById("slider-sub");

  arc.setAttribute("d", sliderArcPath(MONTHS_BACK));

  const hp = sliderHandlePos(MONTHS_BACK);
  handle.setAttribute("cx", hp.x.toFixed(3));
  handle.setAttribute("cy", hp.y.toFixed(3));

  main.textContent = sliderFormat(MONTHS_BACK);
  sub.textContent  = MONTHS_BACK === 0 ? "today only" : "of history";
}

function svgClientToMonths(svgEl, clientX, clientY) {
  const rect   = svgEl.getBoundingClientRect();
  const scaleX = 240 / rect.width;
  const scaleY = 240 / rect.height;
  const svgX   = (clientX - rect.left) * scaleX;
  const svgY   = (clientY - rect.top)  * scaleY;

  // atan2 from center, then normalize clockwise from 12 o'clock
  const angle    = Math.atan2(svgY - SL.cy, svgX - SL.cx) * 180 / Math.PI;
  const adjusted = ((angle + 90) + 360) % 360;
  return Math.round(adjusted / 360 * 48);
}

function initSlider() {
  const svg = document.getElementById("time-slider");

  // Mouse
  svg.addEventListener("mousedown", e => {
    sliderDragging = true;
    document.getElementById("slider-handle").classList.add("dragging");
    updateSlider(svgClientToMonths(svg, e.clientX, e.clientY));
    e.preventDefault();
  });
  document.addEventListener("mousemove", e => {
    if (!sliderDragging) return;
    updateSlider(svgClientToMonths(svg, e.clientX, e.clientY));
  });
  document.addEventListener("mouseup", () => {
    sliderDragging = false;
    const h = document.getElementById("slider-handle");
    if (h) h.classList.remove("dragging");
  });

  // Touch
  svg.addEventListener("touchstart", e => {
    sliderDragging = true;
    const t = e.touches[0];
    updateSlider(svgClientToMonths(svg, t.clientX, t.clientY));
    e.preventDefault();
  }, { passive: false });
  document.addEventListener("touchmove", e => {
    if (!sliderDragging) return;
    const t = e.touches[0];
    updateSlider(svgClientToMonths(svg, t.clientX, t.clientY));
    e.preventDefault();
  }, { passive: false });
  document.addEventListener("touchend", () => { sliderDragging = false; });

  // Set initial position
  updateSlider(18);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BOOT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
initSlider();
init();
</script>
</body>
</html>
